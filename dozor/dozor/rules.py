from __future__ import annotations

import json
import logging
import socket
from pathlib import Path

from .metrics import ips_total, reload_total

log = logging.getLogger(__name__)

# SID base — local rules range
_SID_BASE = 9000001


_CHUNK_SIZE = 200  # Max IPs per rule to stay within Suricata's ~8KB line length limit


def generate_rules(feeds: dict[str, set[str]]) -> str:
    """Generate Suricata drop rules from feed IP sets.

    Splits large feeds into chunks of CHUNK_SIZE IPs per rule to avoid
    exceeding Suricata's rule line length limit.
    """
    lines: list[str] = [
        "# Auto-generated by Dozor — do not edit",
        "",
    ]
    sid = _SID_BASE
    total_ips = 0

    for feed_name, ip_set in sorted(feeds.items()):
        if not ip_set:
            continue
        total_ips += len(ip_set)
        label = feed_name.replace("_", " ").upper()
        sorted_ips = sorted(ip_set)

        for i in range(0, len(sorted_ips), _CHUNK_SIZE):
            chunk = sorted_ips[i : i + _CHUNK_SIZE]
            ip_group = "[" + ",".join(chunk) + "]"
            chunk_n = i // _CHUNK_SIZE + 1

            # Inbound: bad IP -> our network
            lines.append(
                f'drop ip {ip_group} any -> $HOME_NET any '
                f'(msg:"DOZOR {label} inbound {chunk_n}"; sid:{sid}; rev:1;)'
            )
            sid += 1

            # Outbound: our network -> bad IP
            lines.append(
                f'drop ip $HOME_NET any -> {ip_group} any '
                f'(msg:"DOZOR {label} outbound {chunk_n}"; sid:{sid}; rev:1;)'
            )
            sid += 1

    ips_total.set(total_ips)
    lines.append("")
    return "\n".join(lines)


def write_rules(rules_text: str, path: str) -> None:
    """Write rules to file atomically."""
    p = Path(path)
    p.parent.mkdir(parents=True, exist_ok=True)
    tmp = p.with_suffix(".tmp")
    tmp.write_text(rules_text)
    tmp.rename(p)
    log.info("wrote %d bytes to %s", len(rules_text), path)


def reload_suricata(socket_path: str) -> bool:
    """Send reload-rules command via Suricata unix socket.

    Suricata's unix command protocol: connect, receive version JSON,
    send command JSON, receive response JSON.
    """
    try:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect(socket_path)

        # Suricata sends a version banner on connect
        try:
            banner = sock.recv(4096)
            if not banner:
                sock.close()
                reload_total.labels(status="skipped").inc()
                log.info("suricata socket returned empty banner — rules will load on next restart")
                return False
            log.debug("suricata banner: %s", banner.decode(errors="replace"))
        except socket.timeout:
            sock.close()
            reload_total.labels(status="skipped").inc()
            log.info("suricata socket busy (exporter connected) — rules will load on next restart")
            return False

        # Send reload-rules command
        cmd = json.dumps({"command": "reload-rules"})
        sock.send(cmd.encode() + b"\n")

        resp = sock.recv(4096)
        sock.close()

        data = json.loads(resp.decode())
        status = data.get("return", "")
        if status == "OK":
            reload_total.labels(status="ok").inc()
            log.info("suricata rule reload successful")
            return True
        else:
            reload_total.labels(status="error").inc()
            log.error("suricata reload response: %s", data)
            return False
    except FileNotFoundError:
        reload_total.labels(status="error").inc()
        log.warning("suricata socket not found at %s — skipping reload", socket_path)
        return False
    except Exception:
        reload_total.labels(status="error").inc()
        log.exception("failed to reload suricata rules")
        return False
