#!/usr/bin/env python3
"""
Orchestrateur de Pentesting avec Faraday
G√®re ZAP, Burp Suite, Masscan, Nuclei, VulnX et Metasploit
"""

import os
import sys
import json
import importlib
import importlib.util
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Callable
import logging

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('orchestrator.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class PluginManager:
    """Gestionnaire de plugins pour les outils de pentest"""
    
    def __init__(self, plugin_dir="plugins", config_dir="config", results_dir="results"):
        self.plugin_dir = Path(plugin_dir)
        self.config_dir = Path(config_dir)
        self.results_dir = Path(results_dir)
        self.functions = {}
        self.plugins_metadata = {}
        
        # Cr√©er les r√©pertoires si n√©cessaire
        self.plugin_dir.mkdir(exist_ok=True)
        self.config_dir.mkdir(exist_ok=True)
        self.results_dir.mkdir(exist_ok=True)
        
    def install_requirements(self):
        """Installe les d√©pendances depuis requirements.txt"""
        req_file = self.plugin_dir / "requirements.txt"
        if req_file.exists():
            import subprocess
            logger.info("Installation des d√©pendances...")
            try:
                subprocess.check_call([
                    sys.executable, "-m", "pip", "install", 
                    "-r", str(req_file), "--break-system-packages"
                ])
                logger.info("‚úì D√©pendances install√©es")
            except subprocess.CalledProcessError as e:
                logger.error(f"‚úó Erreur d'installation : {e}")
    
    def load_plugins(self):
        """Charge tous les plugins et leurs fonctions"""
        if str(self.plugin_dir) not in sys.path:
            sys.path.insert(0, str(self.plugin_dir))
        
        plugin_count = 0
        for plugin_file in self.plugin_dir.glob("plugin_*.py"):
            module_name = plugin_file.stem
            
            try:
                spec = importlib.util.spec_from_file_location(
                    module_name, plugin_file
                )
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # M√©tadonn√©es du plugin
                plugin_info = {
                    'name': module_name,
                    'description': getattr(module, '__description__', 'No description'),
                    'tool': getattr(module, '__tool__', 'Unknown'),
                    'version': getattr(module, '__version__', '1.0.0'),
                    'functions': []
                }
                
                # Extrait les fonctions publiques
                for name in dir(module):
                    if not name.startswith('_'):
                        obj = getattr(module, name)
                        if callable(obj) and hasattr(obj, '__call__'):
                            func_key = f"{module_name}.{name}"
                            self.functions[func_key] = obj
                            plugin_info['functions'].append(name)
                
                self.plugins_metadata[module_name] = plugin_info
                logger.info(f"‚úì Plugin charg√© : {module_name} ({plugin_info['tool']})")
                plugin_count += 1
                
            except Exception as e:
                logger.error(f"‚úó Erreur avec {module_name}: {e}")
        
        logger.info(f"Total : {plugin_count} plugins charg√©s")
        return plugin_count
    
    def reload_plugins(self):
        """Recharge tous les plugins"""
        logger.info("Rechargement des plugins...")
        self.functions.clear()
        self.plugins_metadata.clear()
        return self.load_plugins()
    
    def list_plugins(self):
        """Liste tous les plugins disponibles"""
        return self.plugins_metadata
    
    def list_functions(self, plugin_name=None):
        """Liste toutes les fonctions disponibles"""
        if plugin_name:
            return [f for f in self.functions.keys() if f.startswith(plugin_name)]
        return list(self.functions.keys())
    
    def execute(self, func_name: str, *args, **kwargs) -> Any:
        """Ex√©cute une fonction du tableau"""
        if func_name in self.functions:
            logger.info(f"Ex√©cution : {func_name}")
            try:
                result = self.functions[func_name](*args, **kwargs)
                logger.info(f"‚úì {func_name} termin√©")
                return result
            except Exception as e:
                logger.error(f"‚úó Erreur dans {func_name}: {e}")
                raise
        else:
            raise KeyError(f"Fonction '{func_name}' non trouv√©e")
    
    def get_function_info(self, func_name: str) -> Dict:
        """R√©cup√®re les informations sur une fonction"""
        if func_name in self.functions:
            func = self.functions[func_name]
            return {
                'name': func_name,
                'doc': func.__doc__ or 'No documentation',
                'module': func.__module__
            }
        return None


class PentestOrchestrator:
    """Orchestrateur principal pour les campagnes de pentest"""
    
    def __init__(self, workspace: str = "default"):
        self.manager = PluginManager()
        self.workspace = workspace
        self.results = []
        self.session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        
    def initialize(self):
        """Initialise l'orchestrateur"""
        logger.info("=" * 60)
        logger.info("Pentest Orchestrator - D√©marrage")
        logger.info("=" * 60)
        
        self.manager.install_requirements()
        self.manager.load_plugins()
        
        logger.info(f"Workspace : {self.workspace}")
        logger.info(f"Session ID : {self.session_id}")
        
    def run_scan_sequence(self, target: str, scan_type: str = "full"):
        """Ex√©cute une s√©quence de scans"""
        logger.info(f"\n{'='*60}")
        logger.info(f"D√©but du scan : {target}")
        logger.info(f"Type : {scan_type}")
        logger.info(f"{'='*60}\n")
        
        results = {
            'target': target,
            'scan_type': scan_type,
            'session_id': self.session_id,
            'workspace': self.workspace,
            'timestamp': datetime.now().isoformat(),
            'scans': []
        }
        
        # S√©quence de scans selon le type
        if scan_type == "full":
            sequence = [
                # Phase 1: Reconnaissance r√©seau
                ('plugin_masscan.quick_scan', {'target': target}),
                # Phase 2: Scan web
                ('plugin_zap.spider_scan', {'target': target}),
                ('plugin_zap.active_scan', {'target': target}),
                ('plugin_burp.passive_scan', {'target': target}),
                # Phase 3: Vuln√©rabilit√©s
                ('plugin_nuclei.quick_scan', {'target': target}),
                ('plugin_vulnx.cms_scan', {'target': target}),
                ('plugin_metasploit.vulnerability_scan', {'target': target}),
            ]
        elif scan_type == "web":
            sequence = [
                # Spider et crawl
                ('plugin_zap.spider_scan', {'target': target}),
                ('plugin_zap.active_scan', {'target': target}),
                ('plugin_burp.passive_scan', {'target': target}),
                # Vuln√©rabilit√©s web
                ('plugin_nuclei.quick_scan', {'target': target}),
                ('plugin_nuclei.technology_scan', {'target': target}),
                ('plugin_vulnx.cms_scan', {'target': target}),
                ('plugin_vulnx.full_scan', {'target': target}),
            ]
        elif scan_type == "network":
            sequence = [
                ('plugin_masscan.full_scan', {'target': target}),
                ('plugin_metasploit.port_scan', {'target': target}),
                ('plugin_nuclei.cve_scan', {'target': target}),
            ]
        elif scan_type == "vuln":
            # Scan de vuln√©rabilit√©s uniquement
            sequence = [
                ('plugin_nuclei.full_scan', {'target': target}),
                ('plugin_nuclei.cve_scan', {'target': target}),
                ('plugin_vulnx.full_scan', {'target': target}),
            ]
        elif scan_type == "cms":
            # Scan CMS cibl√©
            sequence = [
                ('plugin_vulnx.cms_scan', {'target': target}),
                ('plugin_vulnx.wordpress_scan', {'target': target}),
                ('plugin_vulnx.joomla_scan', {'target': target}),
                ('plugin_nuclei.technology_scan', {'target': target}),
            ]
        else:
            logger.error(f"Type de scan inconnu : {scan_type}")
            return None
        
        # Ex√©cute la s√©quence
        for func_name, params in sequence:
            try:
                result = self.manager.execute(func_name, **params)
                results['scans'].append({
                    'function': func_name,
                    'status': 'success',
                    'result': result
                })
            except KeyError:
                logger.warning(f"Fonction non disponible : {func_name}")
                results['scans'].append({
                    'function': func_name,
                    'status': 'skipped',
                    'reason': 'Plugin non charg√©'
                })
            except Exception as e:
                logger.error(f"Erreur lors de {func_name}: {e}")
                results['scans'].append({
                    'function': func_name,
                    'status': 'error',
                    'error': str(e)
                })
        
        # Sauvegarde les r√©sultats
        self.save_results(results)
        
        # Envoie √† Faraday
        self.send_to_faraday(results)
        
        return results
    
    def save_results(self, results: Dict):
        """Sauvegarde les r√©sultats localement"""
        results_file = self.manager.results_dir / f"scan_{self.session_id}.json"
        with open(results_file, 'w') as f:
            json.dump(results, f, indent=2)
        logger.info(f"R√©sultats sauvegard√©s : {results_file}")
    
    def send_to_faraday(self, results: Dict):
        """Envoie les r√©sultats √† Faraday"""
        try:
            func = self.manager.functions.get('plugin_faraday.import_results')
            if func:
                func(workspace=self.workspace, results=results)
                logger.info("‚úì R√©sultats envoy√©s √† Faraday")
            else:
                logger.warning("Plugin Faraday non disponible")
        except Exception as e:
            logger.error(f"Erreur lors de l'envoi √† Faraday : {e}")
    
    def show_status(self):
        """Affiche le statut de l'orchestrateur"""
        print("\n" + "="*60)
        print("STATUS DE L'ORCHESTRATEUR")
        print("="*60)
        print(f"Workspace : {self.workspace}")
        print(f"Session ID : {self.session_id}")
        print(f"\nPlugins charg√©s : {len(self.manager.plugins_metadata)}")
        
        for plugin_name, info in self.manager.plugins_metadata.items():
            print(f"\n  [{info['tool']}] {plugin_name}")
            print(f"    Version : {info['version']}")
            print(f"    Fonctions : {', '.join(info['functions'])}")
        
        print("\n" + "="*60)

def chdir_to_script_dir():
    """Change le r√©pertoire de travail vers le r√©pertoire du script appelant"""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(script_dir)
    return script_dir


def run_daemon(orchestrator: PentestOrchestrator):
    """Mode daemon: √©coute Redis pour les commandes de scan"""
    import time
    try:
        import redis
    except ImportError:
        import subprocess
        subprocess.check_call([sys.executable, "-m", "pip", "install", "redis", "--break-system-packages"])
        import redis

    redis_host = os.environ.get('REDIS_HOST', 'redis')
    redis_port = int(os.environ.get('REDIS_PORT', 6379))
    channel = 'pentest:commands'

    logger.info(f"Mode daemon activ√© - √âcoute sur Redis {redis_host}:{redis_port}")
    logger.info(f"Channel: {channel}")
    logger.info("Commandes disponibles (JSON):")
    logger.info('  {"action": "scan", "target": "192.168.1.1", "type": "full"}')
    logger.info('  {"action": "russia_scan", "ports": "22,80,443", "rate": 100000}  # reset nmap auto')
    logger.info('  {"action": "country_scan", "country_code": "CN", "ports": "22,80,443", "only_unscanned": true}')
    logger.info('  {"action": "status"}')
    logger.info('  {"action": "list"}')
    logger.info('  {"action": "reload"}')

    while True:
        try:
            r = redis.Redis(host=redis_host, port=redis_port, decode_responses=True)
            pubsub = r.pubsub()
            pubsub.subscribe(channel)
            logger.info("‚úì Connect√© √† Redis, en attente de commandes...")

            for message in pubsub.listen():
                if message['type'] == 'message':
                    try:
                        data = json.loads(message['data'])
                        action = data.get('action', '')
                        logger.info(f"Commande re√ßue: {data}")

                        if action == 'scan':
                            target = data.get('target')
                            scan_type = data.get('type', 'full')
                            user_id = data.get('user_id')
                            token = data.get('token')
                            if target:
                                result = orchestrator.run_scan_sequence(target, scan_type)
                                output_lines = [
                                    f"Scan completed for {target}",
                                    f"Type: {scan_type}",
                                    f"Session: {orchestrator.session_id}",
                                    f"Status: {result.get('status', 'completed') if isinstance(result, dict) else 'completed'}",
                                ]
                                if isinstance(result, dict):
                                    for key, val in result.items():
                                        if key not in ('status',):
                                            output_lines.append(f"{key}: {val}")
                                output = "\n".join(output_lines)

                                response = {
                                    'status': 'completed',
                                    'session_id': orchestrator.session_id,
                                    'target': target,
                                    'user_id': user_id,
                                    'token': token,
                                    'output': output,
                                }
                                logger.info(f"Publishing result to pentest:results: user_id={user_id}")
                                r.publish('pentest:results', json.dumps(response))
                            else:
                                logger.error("Cible manquante dans la commande")

                        elif action == 'russia_scan':
                            # Scan IPs russes depuis ip2location
                            # Reset automatique nmap='0' avant scan
                            user_id = data.get('user_id')
                            token = data.get('token')
                            ports = data.get('ports', '22,80,443,3389,8080')
                            rate = data.get('rate', 100000)
                            max_ranges = data.get('max_ranges', 0)

                            logger.info(f"[Daemon] Russia scan: ports={ports}, rate={rate} (reset nmap auto)")
                            try:
                                result = orchestrator.manager.execute(
                                    'plugin_masscan.russia_scan',
                                    ports=ports, rate=rate, max_ranges=max_ranges
                                )
                                output_lines = [
                                    "üá∑üá∫ Russia Scan termin√©",
                                    f"Ports: {ports}",
                                    f"Rate: {rate:,} pps",
                                    f"Status: {result.get('status', 'unknown')}",
                                ]
                                if result.get('status') == 'completed':
                                    output_lines.extend([
                                        f"CIDR scann√©s: {result.get('total_cidrs', 0):,}",
                                        f"IPs cibles: {result.get('total_target_ips', 0):,}",
                                        f"Ports ouverts: {result.get('total_open_ports', 0):,}",
                                    ])
                                    if result.get('port_summary'):
                                        output_lines.append("Top ports:")
                                        for port, count in sorted(result['port_summary'].items(), key=lambda x: -x[1])[:10]:
                                            output_lines.append(f"  {port}: {count:,}")
                                else:
                                    output_lines.append(f"Erreur: {result.get('error', 'inconnue')}")

                                response = {
                                    'status': result.get('status', 'error'),
                                    'session_id': orchestrator.session_id,
                                    'action': 'russia_scan',
                                    'user_id': user_id,
                                    'token': token,
                                    'output': "\n".join(output_lines),
                                    'result': result
                                }
                                r.publish('pentest:results', json.dumps(response))
                            except Exception as e:
                                logger.error(f"Russia scan error: {e}")
                                r.publish('pentest:results', json.dumps({
                                    'status': 'error',
                                    'action': 'russia_scan',
                                    'user_id': user_id,
                                    'token': token,
                                    'output': f"Erreur russia_scan: {e}"
                                }))

                        elif action == 'country_scan':
                            # Scan IPs d'un pays depuis ip2location
                            user_id = data.get('user_id')
                            token = data.get('token')
                            country_code = data.get('country_code', 'RU')
                            ports = data.get('ports', '22,80,443,3389,8080')
                            rate = data.get('rate', 100000)
                            max_ranges = data.get('max_ranges', 0)
                            only_unscanned = data.get('only_unscanned', False)

                            logger.info(f"[Daemon] Country scan: {country_code}, ports={ports}, only_unscanned={only_unscanned}")
                            try:
                                result = orchestrator.manager.execute(
                                    'plugin_masscan.country_scan',
                                    country_code=country_code, ports=ports,
                                    rate=rate, max_ranges=max_ranges,
                                    only_unscanned=only_unscanned
                                )
                                output_lines = [
                                    f"üåç Country Scan [{country_code}] termin√©",
                                    f"Ports: {ports}",
                                    f"Status: {result.get('status', 'unknown')}",
                                ]
                                if result.get('status') == 'completed':
                                    output_lines.extend([
                                        f"CIDR: {result.get('total_cidrs', 0):,}",
                                        f"IPs: {result.get('total_target_ips', 0):,}",
                                        f"Ports ouverts: {result.get('total_open_ports', 0):,}",
                                    ])

                                response = {
                                    'status': result.get('status', 'error'),
                                    'session_id': orchestrator.session_id,
                                    'action': 'country_scan',
                                    'country_code': country_code,
                                    'user_id': user_id,
                                    'token': token,
                                    'output': "\n".join(output_lines),
                                    'result': result
                                }
                                r.publish('pentest:results', json.dumps(response))
                            except Exception as e:
                                logger.error(f"Country scan error: {e}")
                                r.publish('pentest:results', json.dumps({
                                    'status': 'error',
                                    'action': 'country_scan',
                                    'user_id': user_id,
                                    'token': token,
                                    'output': f"Erreur country_scan: {e}"
                                }))

                        elif action == 'status':
                            orchestrator.show_status()

                        elif action == 'list':
                            funcs = orchestrator.manager.list_functions()
                            logger.info(f"Fonctions: {funcs}")

                        elif action == 'reload':
                            orchestrator.manager.reload_plugins()

                        else:
                            logger.warning(f"Action inconnue: {action}")

                    except json.JSONDecodeError as e:
                        logger.error(f"JSON invalide: {e}")

        except redis.ConnectionError as e:
            logger.warning(f"Connexion Redis perdue: {e}, reconnexion dans 5s...")
            time.sleep(5)
        except Exception as e:
            logger.error(f"Erreur daemon: {e}")
            time.sleep(5)


def main():
    """Point d'entr√©e principal"""
    import argparse

    chdir_to_script_dir() 
    parser = argparse.ArgumentParser(
        description='Orchestrateur de Pentesting avec Faraday'
    )
    parser.add_argument('-w', '--workspace', default='default',
                       help='Workspace Faraday')
    parser.add_argument('-t', '--target', help='Cible du scan')
    parser.add_argument('-s', '--scan-type',
                       choices=['full', 'web', 'network', 'vuln', 'cms'],
                       default='full',
                       help='Type de scan (full, web, network, vuln, cms)')
    parser.add_argument('--reload', action='store_true',
                       help='Recharger les plugins')
    parser.add_argument('--status', action='store_true',
                       help='Afficher le statut')
    parser.add_argument('--list', action='store_true',
                       help='Lister les fonctions disponibles')
    parser.add_argument('--daemon', action='store_true',
                       help='Mode daemon: √©coute Redis pour les commandes')

    args = parser.parse_args()
    
    # Initialise l'orchestrateur
    orchestrator = PentestOrchestrator(workspace=args.workspace)
    orchestrator.initialize()
    
    # Commandes
    if args.reload:
        orchestrator.manager.reload_plugins()
    
    if args.status:
        orchestrator.show_status()
    
    if args.list:
        print("\nFonctions disponibles :")
        for func in orchestrator.manager.list_functions():
            info = orchestrator.manager.get_function_info(func)
            print(f"  - {func}")
            if info['doc'] != 'No documentation':
                print(f"    {info['doc']}")
    
    if args.target:
        orchestrator.run_scan_sequence(args.target, args.scan_type)

    if args.daemon:
        run_daemon(orchestrator)

    if not any([args.status, args.list, args.target, args.reload, args.daemon]):
        parser.print_help()


if __name__ == "__main__":
    main()

