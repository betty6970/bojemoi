#!/usr/bin/env python3
"""
Orchestrateur de Pentesting avec Faraday
Gère ZAP, Burp Suite, Masscan, Nuclei, VulnX et Metasploit
"""

import os
import sys
import json
import importlib
import importlib.util
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Callable
import logging

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('orchestrator.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class PluginManager:
    """Gestionnaire de plugins pour les outils de pentest"""
    
    def __init__(self, plugin_dir="plugins", config_dir="config", results_dir="results"):
        self.plugin_dir = Path(plugin_dir)
        self.config_dir = Path(config_dir)
        self.results_dir = Path(results_dir)
        self.functions = {}
        self.plugins_metadata = {}
        
        # Créer les répertoires si nécessaire
        self.plugin_dir.mkdir(exist_ok=True)
        self.config_dir.mkdir(exist_ok=True)
        self.results_dir.mkdir(exist_ok=True)
        
    def install_requirements(self):
        """Installe les dépendances depuis requirements.txt"""
        req_file = self.plugin_dir / "requirements.txt"
        if req_file.exists():
            import subprocess
            logger.info("Installation des dépendances...")
            try:
                subprocess.check_call([
                    sys.executable, "-m", "pip", "install", 
                    "-r", str(req_file), "--break-system-packages"
                ])
                logger.info("✓ Dépendances installées")
            except subprocess.CalledProcessError as e:
                logger.error(f"✗ Erreur d'installation : {e}")
    
    def load_plugins(self):
        """Charge tous les plugins et leurs fonctions"""
        if str(self.plugin_dir) not in sys.path:
            sys.path.insert(0, str(self.plugin_dir))
        
        plugin_count = 0
        for plugin_file in self.plugin_dir.glob("plugin_*.py"):
            module_name = plugin_file.stem
            
            try:
                spec = importlib.util.spec_from_file_location(
                    module_name, plugin_file
                )
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # Métadonnées du plugin
                plugin_info = {
                    'name': module_name,
                    'description': getattr(module, '__description__', 'No description'),
                    'tool': getattr(module, '__tool__', 'Unknown'),
                    'version': getattr(module, '__version__', '1.0.0'),
                    'functions': []
                }
                
                # Extrait les fonctions publiques
                for name in dir(module):
                    if not name.startswith('_'):
                        obj = getattr(module, name)
                        if callable(obj) and hasattr(obj, '__call__'):
                            func_key = f"{module_name}.{name}"
                            self.functions[func_key] = obj
                            plugin_info['functions'].append(name)
                
                self.plugins_metadata[module_name] = plugin_info
                logger.info(f"✓ Plugin chargé : {module_name} ({plugin_info['tool']})")
                plugin_count += 1
                
            except Exception as e:
                logger.error(f"✗ Erreur avec {module_name}: {e}")
        
        logger.info(f"Total : {plugin_count} plugins chargés")
        return plugin_count
    
    def reload_plugins(self):
        """Recharge tous les plugins"""
        logger.info("Rechargement des plugins...")
        self.functions.clear()
        self.plugins_metadata.clear()
        return self.load_plugins()
    
    def list_plugins(self):
        """Liste tous les plugins disponibles"""
        return self.plugins_metadata
    
    def list_functions(self, plugin_name=None):
        """Liste toutes les fonctions disponibles"""
        if plugin_name:
            return [f for f in self.functions.keys() if f.startswith(plugin_name)]
        return list(self.functions.keys())
    
    def execute(self, func_name: str, *args, **kwargs) -> Any:
        """Exécute une fonction du tableau"""
        if func_name in self.functions:
            logger.info(f"Exécution : {func_name}")
            try:
                result = self.functions[func_name](*args, **kwargs)
                logger.info(f"✓ {func_name} terminé")
                return result
            except Exception as e:
                logger.error(f"✗ Erreur dans {func_name}: {e}")
                raise
        else:
            raise KeyError(f"Fonction '{func_name}' non trouvée")
    
    def get_function_info(self, func_name: str) -> Dict:
        """Récupère les informations sur une fonction"""
        if func_name in self.functions:
            func = self.functions[func_name]
            return {
                'name': func_name,
                'doc': func.__doc__ or 'No documentation',
                'module': func.__module__
            }
        return None


class PentestOrchestrator:
    """Orchestrateur principal pour les campagnes de pentest"""
    
    def __init__(self, workspace: str = "default"):
        self.manager = PluginManager()
        self.workspace = workspace
        self.results = []
        self.session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        
    def initialize(self):
        """Initialise l'orchestrateur"""
        logger.info("=" * 60)
        logger.info("Pentest Orchestrator - Démarrage")
        logger.info("=" * 60)
        
        self.manager.install_requirements()
        self.manager.load_plugins()
        
        logger.info(f"Workspace : {self.workspace}")
        logger.info(f"Session ID : {self.session_id}")
        
    def run_scan_sequence(self, target: str, scan_type: str = "full"):
        """Exécute une séquence de scans"""
        logger.info(f"\n{'='*60}")
        logger.info(f"Début du scan : {target}")
        logger.info(f"Type : {scan_type}")
        logger.info(f"{'='*60}\n")
        
        results = {
            'target': target,
            'scan_type': scan_type,
            'session_id': self.session_id,
            'workspace': self.workspace,
            'timestamp': datetime.now().isoformat(),
            'scans': []
        }
        
        # Séquence de scans selon le type
        if scan_type == "full":
            sequence = [
                # Phase 1: Reconnaissance réseau
                ('plugin_masscan.quick_scan', {'target': target}),
                # Phase 2: Scan web
                ('plugin_zap.spider_scan', {'target': target}),
                ('plugin_zap.active_scan', {'target': target}),
                ('plugin_burp.passive_scan', {'target': target}),
                # Phase 3: Vulnérabilités
                ('plugin_nuclei.quick_scan', {'target': target}),
                ('plugin_vulnx.cms_scan', {'target': target}),
                ('plugin_metasploit.vulnerability_scan', {'target': target}),
            ]
        elif scan_type == "web":
            sequence = [
                # Spider et crawl
                ('plugin_zap.spider_scan', {'target': target}),
                ('plugin_zap.active_scan', {'target': target}),
                ('plugin_burp.passive_scan', {'target': target}),
                # Vulnérabilités web
                ('plugin_nuclei.quick_scan', {'target': target}),
                ('plugin_nuclei.technology_scan', {'target': target}),
                ('plugin_vulnx.cms_scan', {'target': target}),
                ('plugin_vulnx.full_scan', {'target': target}),
            ]
        elif scan_type == "network":
            sequence = [
                ('plugin_masscan.full_scan', {'target': target}),
                ('plugin_metasploit.port_scan', {'target': target}),
                ('plugin_nuclei.cve_scan', {'target': target}),
            ]
        elif scan_type == "vuln":
            # Scan de vulnérabilités uniquement
            sequence = [
                ('plugin_nuclei.full_scan', {'target': target}),
                ('plugin_nuclei.cve_scan', {'target': target}),
                ('plugin_vulnx.full_scan', {'target': target}),
            ]
        elif scan_type == "cms":
            # Scan CMS ciblé
            sequence = [
                ('plugin_vulnx.cms_scan', {'target': target}),
                ('plugin_vulnx.wordpress_scan', {'target': target}),
                ('plugin_vulnx.joomla_scan', {'target': target}),
                ('plugin_nuclei.technology_scan', {'target': target}),
            ]
        else:
            logger.error(f"Type de scan inconnu : {scan_type}")
            return None
        
        # Exécute la séquence
        for func_name, params in sequence:
            try:
                result = self.manager.execute(func_name, **params)
                results['scans'].append({
                    'function': func_name,
                    'status': 'success',
                    'result': result
                })
            except KeyError:
                logger.warning(f"Fonction non disponible : {func_name}")
                results['scans'].append({
                    'function': func_name,
                    'status': 'skipped',
                    'reason': 'Plugin non chargé'
                })
            except Exception as e:
                logger.error(f"Erreur lors de {func_name}: {e}")
                results['scans'].append({
                    'function': func_name,
                    'status': 'error',
                    'error': str(e)
                })
        
        # Sauvegarde les résultats
        self.save_results(results)
        
        # Envoie à Faraday
        self.send_to_faraday(results)
        
        return results
    
    def save_results(self, results: Dict):
        """Sauvegarde les résultats localement"""
        results_file = self.manager.results_dir / f"scan_{self.session_id}.json"
        with open(results_file, 'w') as f:
            json.dump(results, f, indent=2)
        logger.info(f"Résultats sauvegardés : {results_file}")
    
    def send_to_faraday(self, results: Dict):
        """Envoie les résultats à Faraday"""
        try:
            func = self.manager.functions.get('plugin_faraday.import_results')
            if func:
                func(workspace=self.workspace, results=results)
                logger.info("✓ Résultats envoyés à Faraday")
            else:
                logger.warning("Plugin Faraday non disponible")
        except Exception as e:
            logger.error(f"Erreur lors de l'envoi à Faraday : {e}")
    
    def show_status(self):
        """Affiche le statut de l'orchestrateur"""
        print("\n" + "="*60)
        print("STATUS DE L'ORCHESTRATEUR")
        print("="*60)
        print(f"Workspace : {self.workspace}")
        print(f"Session ID : {self.session_id}")
        print(f"\nPlugins chargés : {len(self.manager.plugins_metadata)}")
        
        for plugin_name, info in self.manager.plugins_metadata.items():
            print(f"\n  [{info['tool']}] {plugin_name}")
            print(f"    Version : {info['version']}")
            print(f"    Fonctions : {', '.join(info['functions'])}")
        
        print("\n" + "="*60)

def chdir_to_script_dir():
    """Change le répertoire de travail vers le répertoire du script appelant"""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(script_dir)
    return script_dir


def run_daemon(orchestrator: PentestOrchestrator):
    """Mode daemon: écoute Redis pour les commandes de scan"""
    import time
    try:
        import redis
    except ImportError:
        import subprocess
        subprocess.check_call([sys.executable, "-m", "pip", "install", "redis", "--break-system-packages"])
        import redis

    redis_host = os.environ.get('REDIS_HOST', 'redis')
    redis_port = int(os.environ.get('REDIS_PORT', 6379))
    channel = 'pentest:commands'

    logger.info(f"Mode daemon activé - Écoute sur Redis {redis_host}:{redis_port}")
    logger.info(f"Channel: {channel}")
    logger.info("Commandes disponibles (JSON):")
    logger.info('  {"action": "scan", "target": "192.168.1.1", "type": "full"}')
    logger.info('  {"action": "status"}')
    logger.info('  {"action": "list"}')
    logger.info('  {"action": "reload"}')

    while True:
        try:
            r = redis.Redis(host=redis_host, port=redis_port, decode_responses=True)
            pubsub = r.pubsub()
            pubsub.subscribe(channel)
            logger.info("✓ Connecté à Redis, en attente de commandes...")

            for message in pubsub.listen():
                if message['type'] == 'message':
                    try:
                        data = json.loads(message['data'])
                        action = data.get('action', '')
                        logger.info(f"Commande reçue: {data}")

                        if action == 'scan':
                            target = data.get('target')
                            scan_type = data.get('type', 'full')
                            if target:
                                result = orchestrator.run_scan_sequence(target, scan_type)
                                r.publish('pentest:results', json.dumps({
                                    'status': 'completed',
                                    'session_id': orchestrator.session_id,
                                    'target': target
                                }))
                            else:
                                logger.error("Cible manquante dans la commande")

                        elif action == 'status':
                            orchestrator.show_status()

                        elif action == 'list':
                            funcs = orchestrator.manager.list_functions()
                            logger.info(f"Fonctions: {funcs}")

                        elif action == 'reload':
                            orchestrator.manager.reload_plugins()

                        else:
                            logger.warning(f"Action inconnue: {action}")

                    except json.JSONDecodeError as e:
                        logger.error(f"JSON invalide: {e}")

        except redis.ConnectionError as e:
            logger.warning(f"Connexion Redis perdue: {e}, reconnexion dans 5s...")
            time.sleep(5)
        except Exception as e:
            logger.error(f"Erreur daemon: {e}")
            time.sleep(5)


def main():
    """Point d'entrée principal"""
    import argparse

    chdir_to_script_dir() 
    parser = argparse.ArgumentParser(
        description='Orchestrateur de Pentesting avec Faraday'
    )
    parser.add_argument('-w', '--workspace', default='default',
                       help='Workspace Faraday')
    parser.add_argument('-t', '--target', help='Cible du scan')
    parser.add_argument('-s', '--scan-type',
                       choices=['full', 'web', 'network', 'vuln', 'cms'],
                       default='full',
                       help='Type de scan (full, web, network, vuln, cms)')
    parser.add_argument('--reload', action='store_true',
                       help='Recharger les plugins')
    parser.add_argument('--status', action='store_true',
                       help='Afficher le statut')
    parser.add_argument('--list', action='store_true',
                       help='Lister les fonctions disponibles')
    parser.add_argument('--daemon', action='store_true',
                       help='Mode daemon: écoute Redis pour les commandes')

    args = parser.parse_args()
    
    # Initialise l'orchestrateur
    orchestrator = PentestOrchestrator(workspace=args.workspace)
    orchestrator.initialize()
    
    # Commandes
    if args.reload:
        orchestrator.manager.reload_plugins()
    
    if args.status:
        orchestrator.show_status()
    
    if args.list:
        print("\nFonctions disponibles :")
        for func in orchestrator.manager.list_functions():
            info = orchestrator.manager.get_function_info(func)
            print(f"  - {func}")
            if info['doc'] != 'No documentation':
                print(f"    {info['doc']}")
    
    if args.target:
        orchestrator.run_scan_sequence(args.target, args.scan_type)

    if args.daemon:
        run_daemon(orchestrator)

    if not any([args.status, args.list, args.target, args.reload, args.daemon]):
        parser.print_help()


if __name__ == "__main__":
    main()

