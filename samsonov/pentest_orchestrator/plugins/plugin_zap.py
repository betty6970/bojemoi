#!/usr/bin/env python3
"""
Plugin OWASP ZAP pour l'orchestrateur
"""

__description__ = "Plugin pour OWASP ZAP (Zed Attack Proxy)"
__tool__ = "OWASP ZAP"
__version__ = "1.0.0"

import requests
import time
import json
from typing import Dict, List

# Configuration par défaut
ZAP_API_KEY = "changeme"  # À configurer
ZAP_PROXY = "http://127.0.0.1:8080"
ZAP_API_URL = f"{ZAP_PROXY}"


def spider_scan(target: str, max_depth: int = 5) -> Dict:
    """
    Lance un spider scan sur la cible
    
    Args:
        target: URL cible
        max_depth: Profondeur maximale du crawl
    
    Returns:
        Résultats du spider scan
    """
    print(f"[ZAP] Spider scan : {target}")
    
    try:
        # Démarre le spider
        response = requests.get(
            f"{ZAP_API_URL}/JSON/spider/action/scan/",
            params={
                'apikey': ZAP_API_KEY,
                'url': target,
                'maxChildren': max_depth
            }
        )
        
        if response.status_code == 200:
            scan_data = response.json()
            scan_id = scan_data.get('scan', 'unknown')
            
            # Attend la fin du scan
            while True:
                status_response = requests.get(
                    f"{ZAP_API_URL}/JSON/spider/view/status/",
                    params={
                        'apikey': ZAP_API_KEY,
                        'scanId': scan_id
                    }
                )
                
                status = int(status_response.json().get('status', 0))
                print(f"[ZAP] Spider progression : {status}%")
                
                if status >= 100:
                    break
                time.sleep(2)
            
            # Récupère les résultats
            results_response = requests.get(
                f"{ZAP_API_URL}/JSON/spider/view/results/",
                params={
                    'apikey': ZAP_API_KEY,
                    'scanId': scan_id
                }
            )
            
            urls_found = results_response.json().get('results', [])
            
            return {
                'tool': 'ZAP Spider',
                'target': target,
                'scan_id': scan_id,
                'urls_found': len(urls_found),
                'urls': urls_found[:50],  # Limite les résultats
                'status': 'completed'
            }
        else:
            return {
                'tool': 'ZAP Spider',
                'target': target,
                'status': 'error',
                'error': f"HTTP {response.status_code}"
            }
            
    except requests.exceptions.ConnectionError:
        print("[ZAP] ERREUR : ZAP n'est pas accessible. Vérifiez qu'il est démarré.")
        return {
            'tool': 'ZAP Spider',
            'target': target,
            'status': 'error',
            'error': 'ZAP not reachable'
        }
    except Exception as e:
        return {
            'tool': 'ZAP Spider',
            'target': target,
            'status': 'error',
            'error': str(e)
        }


def active_scan(target: str, scan_policy: str = "Default Policy") -> Dict:
    """
    Lance un scan actif sur la cible
    
    Args:
        target: URL cible
        scan_policy: Politique de scan à utiliser
    
    Returns:
        Résultats du scan actif
    """
    print(f"[ZAP] Active scan : {target}")
    
    try:
        # Démarre le scan actif
        response = requests.get(
            f"{ZAP_API_URL}/JSON/ascan/action/scan/",
            params={
                'apikey': ZAP_API_KEY,
                'url': target,
                'recurse': 'true',
                'inScopeOnly': 'false'
            }
        )
        
        if response.status_code == 200:
            scan_data = response.json()
            scan_id = scan_data.get('scan', 'unknown')
            
            # Attend la fin du scan
            while True:
                status_response = requests.get(
                    f"{ZAP_API_URL}/JSON/ascan/view/status/",
                    params={
                        'apikey': ZAP_API_KEY,
                        'scanId': scan_id
                    }
                )
                
                status = int(status_response.json().get('status', 0))
                print(f"[ZAP] Active scan progression : {status}%")
                
                if status >= 100:
                    break
                time.sleep(5)
            
            # Récupère les alertes
            alerts_response = requests.get(
                f"{ZAP_API_URL}/JSON/core/view/alerts/",
                params={
                    'apikey': ZAP_API_KEY,
                    'baseurl': target
                }
            )
            
            alerts = alerts_response.json().get('alerts', [])
            
            # Compte les vulnérabilités par sévérité
            severity_count = {'High': 0, 'Medium': 0, 'Low': 0, 'Informational': 0}
            for alert in alerts:
                risk = alert.get('risk', 'Informational')
                severity_count[risk] = severity_count.get(risk, 0) + 1
            
            return {
                'tool': 'ZAP Active Scan',
                'target': target,
                'scan_id': scan_id,
                'total_alerts': len(alerts),
                'severity_breakdown': severity_count,
                'alerts': alerts,
                'status': 'completed'
            }
        else:
            return {
                'tool': 'ZAP Active Scan',
                'target': target,
                'status': 'error',
                'error': f"HTTP {response.status_code}"
            }
            
    except requests.exceptions.ConnectionError:
        print("[ZAP] ERREUR : ZAP n'est pas accessible")
        return {
            'tool': 'ZAP Active Scan',
            'target': target,
            'status': 'error',
            'error': 'ZAP not reachable'
        }
    except Exception as e:
        return {
            'tool': 'ZAP Active Scan',
            'target': target,
            'status': 'error',
            'error': str(e)
        }


def export_report(target: str, output_format: str = "json") -> Dict:
    """
    Exporte un rapport ZAP
    
    Args:
        target: URL cible
        output_format: Format (json, html, xml)
    
    Returns:
        Chemin du rapport généré
    """
    print(f"[ZAP] Export rapport : {output_format}")
    
    try:
        if output_format == "json":
            alerts_response = requests.get(
                f"{ZAP_API_URL}/JSON/core/view/alerts/",
                params={
                    'apikey': ZAP_API_KEY,
                    'baseurl': target
                }
            )
            
            report_path = f"results/zap_report_{int(time.time())}.json"
            with open(report_path, 'w') as f:
                json.dump(alerts_response.json(), f, indent=2)
            
            return {
                'tool': 'ZAP Report',
                'format': output_format,
                'report_path': report_path,
                'status': 'completed'
            }
        
        elif output_format == "html":
            report_response = requests.get(
                f"{ZAP_API_URL}/OTHER/core/other/htmlreport/",
                params={'apikey': ZAP_API_KEY}
            )
            
            report_path = f"results/zap_report_{int(time.time())}.html"
            with open(report_path, 'wb') as f:
                f.write(report_response.content)
            
            return {
                'tool': 'ZAP Report',
                'format': output_format,
                'report_path': report_path,
                'status': 'completed'
            }
        
    except Exception as e:
        return {
            'tool': 'ZAP Report',
            'status': 'error',
            'error': str(e)
        }


def get_status() -> Dict:
    """Vérifie le statut de ZAP"""
    try:
        response = requests.get(
            f"{ZAP_API_URL}/JSON/core/view/version/",
            params={'apikey': ZAP_API_KEY},
            timeout=5
        )
        
        if response.status_code == 200:
            version = response.json().get('version', 'unknown')
            return {
                'tool': 'ZAP',
                'status': 'online',
                'version': version,
                'proxy': ZAP_PROXY
            }
        else:
            return {
                'tool': 'ZAP',
                'status': 'error',
                'error': f"HTTP {response.status_code}"
            }
    except Exception as e:
        return {
            'tool': 'ZAP',
            'status': 'offline',
            'error': str(e)
        }



