#!/usr/bin/env python3
"""
Base classes and interfaces for pentest orchestrator plugins.

This module provides:
- Abstract base class for plugin implementations
- Standardized enums for scan types and severity levels
- Finding dataclass for normalized vulnerability results
- Utility functions for common plugin operations

Plugins can either:
1. Inherit from PentestPlugin (recommended for new plugins)
2. Use the module-level function pattern (backward compatible)
"""

__description__ = "Base classes for pentest plugins"
__tool__ = "Base"
__version__ = "1.0.0"

import hashlib
import ipaddress
import json
import logging
import os
import re
import subprocess
import time
from abc import ABC, abstractmethod
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Union
from urllib.parse import urlparse

logger = logging.getLogger(__name__)


class ScanType(str, Enum):
    """Types of security scans supported by the orchestrator."""
    FULL = "full"
    WEB = "web"
    NETWORK = "network"
    VULN = "vuln"
    CMS = "cms"
    RECON = "recon"
    API = "api"

    @classmethod
    def from_string(cls, value: str) -> "ScanType":
        """Convert string to ScanType, with fallback to FULL."""
        try:
            return cls(value.lower())
        except ValueError:
            return cls.FULL


class Severity(str, Enum):
    """Vulnerability severity levels (aligned with CVSS v3)."""
    CRITICAL = "critical"  # CVSS 9.0-10.0
    HIGH = "high"          # CVSS 7.0-8.9
    MEDIUM = "medium"      # CVSS 4.0-6.9
    LOW = "low"            # CVSS 0.1-3.9
    INFO = "info"          # CVSS 0.0 / Informational

    @classmethod
    def from_cvss(cls, score: float) -> "Severity":
        """Convert CVSS score to severity level."""
        if score >= 9.0:
            return cls.CRITICAL
        elif score >= 7.0:
            return cls.HIGH
        elif score >= 4.0:
            return cls.MEDIUM
        elif score > 0:
            return cls.LOW
        return cls.INFO

    @classmethod
    def from_string(cls, value: str) -> "Severity":
        """Convert string to Severity, with fallback to INFO."""
        if not value:
            return cls.INFO
        value = value.lower().strip()
        # Handle common aliases
        aliases = {
            "informational": cls.INFO,
            "information": cls.INFO,
            "none": cls.INFO,
        }
        if value in aliases:
            return aliases[value]
        try:
            return cls(value)
        except ValueError:
            return cls.INFO


class ScanStatus(str, Enum):
    """Status of a scan operation."""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    TIMEOUT = "timeout"
    SKIPPED = "skipped"


@dataclass
class Finding:
    """
    Standardized security finding/vulnerability.

    This class normalizes findings from different tools into a common format
    that can be easily imported into Faraday or other vulnerability management
    platforms.
    """
    title: str
    severity: Severity
    description: str = ""
    cve: Optional[str] = None
    cvss: Optional[float] = None
    cwe: Optional[str] = None
    host: Optional[str] = None
    port: Optional[int] = None
    protocol: Optional[str] = None
    path: Optional[str] = None
    method: Optional[str] = None
    parameter: Optional[str] = None
    evidence: Optional[str] = None
    request: Optional[str] = None
    response: Optional[str] = None
    remediation: Optional[str] = None
    references: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    tool: Optional[str] = None
    raw_data: Optional[Dict[str, Any]] = None
    timestamp: str = field(default_factory=lambda: datetime.utcnow().isoformat())

    def __post_init__(self):
        """Normalize severity if passed as string."""
        if isinstance(self.severity, str):
            self.severity = Severity.from_string(self.severity)

    def to_dict(self) -> Dict[str, Any]:
        """Convert finding to dictionary."""
        data = asdict(self)
        data['severity'] = self.severity.value
        return data

    def to_faraday_format(self) -> Dict[str, Any]:
        """Convert to Faraday API format."""
        return {
            "name": self.title,
            "desc": self.description,
            "severity": self.severity.value,
            "refs": self.references,
            "resolution": self.remediation or "",
            "data": self.evidence or "",
            "type": "Vulnerability",
            "tags": self.tags,
            "cve": [self.cve] if self.cve else [],
            "cwe": [self.cwe] if self.cwe else [],
            "path": self.path or "",
            "method": self.method or "",
            "params": self.parameter or "",
            "request": self.request or "",
            "response": self.response or "",
        }

    @classmethod
    def from_nuclei(cls, result: Dict[str, Any]) -> "Finding":
        """Create Finding from Nuclei JSON output."""
        info = result.get("info", {})
        classification = info.get("classification", {})

        return cls(
            title=info.get("name", "Unknown"),
            severity=Severity.from_string(info.get("severity", "info")),
            description=info.get("description", ""),
            cve=classification.get("cve-id"),
            cvss=classification.get("cvss-score"),
            cwe=classification.get("cwe-id"),
            host=result.get("host"),
            path=result.get("matched-at"),
            remediation=info.get("remediation"),
            references=info.get("reference", []),
            tags=info.get("tags", []),
            tool="nuclei",
            raw_data=result,
        )

    @classmethod
    def from_zap(cls, alert: Dict[str, Any]) -> "Finding":
        """Create Finding from ZAP alert."""
        # Map ZAP risk levels to Severity
        risk_map = {
            "High": Severity.HIGH,
            "Medium": Severity.MEDIUM,
            "Low": Severity.LOW,
            "Informational": Severity.INFO,
        }

        return cls(
            title=alert.get("name", alert.get("alert", "Unknown")),
            severity=risk_map.get(alert.get("risk", "Informational"), Severity.INFO),
            description=alert.get("description", ""),
            cwe=alert.get("cweid"),
            host=alert.get("url"),
            path=alert.get("url"),
            method=alert.get("method"),
            parameter=alert.get("param"),
            evidence=alert.get("evidence"),
            request=alert.get("attack"),
            remediation=alert.get("solution"),
            references=alert.get("reference", "").split("\n") if alert.get("reference") else [],
            tool="zap",
            raw_data=alert,
        )

    @classmethod
    def from_masscan(cls, port_info: Dict[str, Any]) -> "Finding":
        """Create Finding from Masscan port discovery."""
        return cls(
            title=f"Open Port {port_info.get('port', 'unknown')}",
            severity=Severity.INFO,
            description=f"Open {port_info.get('protocol', 'tcp')} port discovered",
            host=port_info.get("ip"),
            port=port_info.get("port"),
            protocol=port_info.get("protocol", "tcp"),
            tool="masscan",
            raw_data=port_info,
        )


@dataclass
class ScanResult:
    """
    Standardized scan result container.

    Provides a consistent structure for all scan results regardless of
    the underlying tool.
    """
    tool: str
    target: str
    status: ScanStatus
    findings: List[Finding] = field(default_factory=list)
    raw_output: Optional[str] = None
    output_file: Optional[str] = None
    error: Optional[str] = None
    duration_seconds: Optional[float] = None
    started_at: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    completed_at: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Normalize status if passed as string."""
        if isinstance(self.status, str):
            self.status = ScanStatus(self.status)

    @property
    def severity_summary(self) -> Dict[str, int]:
        """Count findings by severity level."""
        summary = {s.value: 0 for s in Severity}
        for finding in self.findings:
            summary[finding.severity.value] += 1
        return summary

    @property
    def total_findings(self) -> int:
        """Total number of findings."""
        return len(self.findings)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "tool": self.tool,
            "target": self.target,
            "status": self.status.value,
            "total_findings": self.total_findings,
            "severity_breakdown": self.severity_summary,
            "findings": [f.to_dict() for f in self.findings],
            "raw_output": self.raw_output,
            "output_file": self.output_file,
            "error": self.error,
            "duration_seconds": self.duration_seconds,
            "started_at": self.started_at,
            "completed_at": self.completed_at,
            "metadata": self.metadata,
        }


class PentestPlugin(ABC):
    """
    Abstract base class for pentest plugins.

    New plugins should inherit from this class and implement the required
    abstract methods. This provides a consistent interface for the plugin
    manager while allowing tool-specific implementations.

    Example:
        class MyPlugin(PentestPlugin):
            @property
            def name(self) -> str:
                return "my_plugin"

            @property
            def tool(self) -> str:
                return "MyTool"

            @property
            def version(self) -> str:
                return "1.0.0"

            @property
            def scan_types(self) -> List[ScanType]:
                return [ScanType.WEB, ScanType.VULN]

            def scan(self, target: str, options: Dict = None) -> ScanResult:
                # Implement scan logic
                pass
    """

    def __init__(self, results_dir: str = "results", config_dir: str = "config"):
        """
        Initialize the plugin.

        Args:
            results_dir: Directory for storing scan results
            config_dir: Directory for plugin configuration
        """
        self.results_dir = Path(results_dir)
        self.config_dir = Path(config_dir)
        self.results_dir.mkdir(exist_ok=True)
        self.config_dir.mkdir(exist_ok=True)
        self._logger = logging.getLogger(f"plugin.{self.name}")

    @property
    @abstractmethod
    def name(self) -> str:
        """Unique plugin identifier (e.g., 'nuclei', 'zap')."""
        pass

    @property
    @abstractmethod
    def tool(self) -> str:
        """Display name of the underlying tool (e.g., 'Nuclei', 'OWASP ZAP')."""
        pass

    @property
    @abstractmethod
    def version(self) -> str:
        """Plugin version string."""
        pass

    @property
    @abstractmethod
    def scan_types(self) -> List[ScanType]:
        """List of scan types this plugin supports."""
        pass

    @property
    def description(self) -> str:
        """Plugin description. Override for custom description."""
        return f"Plugin for {self.tool}"

    @abstractmethod
    def scan(self, target: str, options: Optional[Dict[str, Any]] = None) -> ScanResult:
        """
        Execute a scan against the target.

        This is the main entry point for running scans. Implementations should:
        1. Validate the target
        2. Execute the underlying tool
        3. Parse results into Finding objects
        4. Return a ScanResult

        Args:
            target: IP address, domain, or URL to scan
            options: Plugin-specific options

        Returns:
            ScanResult containing findings and metadata
        """
        pass

    def get_status(self) -> Dict[str, Any]:
        """
        Check if the underlying tool is available and get version info.

        Override this method to implement tool-specific status checks.

        Returns:
            Dictionary with tool status information
        """
        return {
            "tool": self.tool,
            "plugin": self.name,
            "version": self.version,
            "status": "unknown",
        }

    def validate_target(self, target: str) -> bool:
        """
        Validate that target is a valid IP, domain, or URL.

        Args:
            target: Target string to validate

        Returns:
            True if target is valid, False otherwise
        """
        return TargetValidator.is_valid(target)

    def get_target_type(self, target: str) -> str:
        """
        Determine the type of target (ip, domain, url, cidr).

        Args:
            target: Target string

        Returns:
            Target type string
        """
        return TargetValidator.get_type(target)

    def generate_output_filename(self, prefix: str, extension: str = "json") -> Path:
        """
        Generate a unique output filename for scan results.

        Args:
            prefix: Filename prefix (e.g., 'nuclei_scan')
            extension: File extension without dot

        Returns:
            Path object for the output file
        """
        timestamp = int(time.time())
        filename = f"{prefix}_{timestamp}.{extension}"
        return self.results_dir / filename

    def run_command(
        self,
        cmd: List[str],
        timeout: int = 300,
        capture_output: bool = True
    ) -> subprocess.CompletedProcess:
        """
        Execute a shell command with timeout.

        Args:
            cmd: Command and arguments as list
            timeout: Timeout in seconds
            capture_output: Whether to capture stdout/stderr

        Returns:
            CompletedProcess instance

        Raises:
            subprocess.TimeoutExpired: If command times out
            FileNotFoundError: If command not found
        """
        self._logger.debug(f"Executing: {' '.join(cmd)}")
        return subprocess.run(
            cmd,
            capture_output=capture_output,
            text=True,
            timeout=timeout
        )

    def log_info(self, message: str):
        """Log info message with plugin prefix."""
        self._logger.info(f"[{self.tool}] {message}")

    def log_error(self, message: str):
        """Log error message with plugin prefix."""
        self._logger.error(f"[{self.tool}] {message}")

    def log_warning(self, message: str):
        """Log warning message with plugin prefix."""
        self._logger.warning(f"[{self.tool}] {message}")


class TargetValidator:
    """Utility class for validating and classifying scan targets."""

    # Regex patterns
    IP_PATTERN = re.compile(
        r'^(\d{1,3}\.){3}\d{1,3}$'
    )
    CIDR_PATTERN = re.compile(
        r'^(\d{1,3}\.){3}\d{1,3}/\d{1,2}$'
    )
    DOMAIN_PATTERN = re.compile(
        r'^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$'
    )
    URL_PATTERN = re.compile(
        r'^https?://'
    )

    @classmethod
    def is_valid_ip(cls, target: str) -> bool:
        """Check if target is a valid IPv4 address."""
        try:
            ipaddress.ip_address(target)
            return True
        except ValueError:
            return False

    @classmethod
    def is_valid_cidr(cls, target: str) -> bool:
        """Check if target is a valid CIDR notation."""
        try:
            ipaddress.ip_network(target, strict=False)
            return True
        except ValueError:
            return False

    @classmethod
    def is_valid_domain(cls, target: str) -> bool:
        """Check if target is a valid domain name."""
        return bool(cls.DOMAIN_PATTERN.match(target))

    @classmethod
    def is_valid_url(cls, target: str) -> bool:
        """Check if target is a valid URL."""
        if not cls.URL_PATTERN.match(target):
            return False
        try:
            result = urlparse(target)
            return all([result.scheme, result.netloc])
        except Exception:
            return False

    @classmethod
    def is_valid(cls, target: str) -> bool:
        """Check if target is any valid type."""
        return (
            cls.is_valid_ip(target) or
            cls.is_valid_cidr(target) or
            cls.is_valid_domain(target) or
            cls.is_valid_url(target)
        )

    @classmethod
    def get_type(cls, target: str) -> str:
        """
        Determine target type.

        Returns:
            One of: 'ip', 'cidr', 'domain', 'url', 'unknown'
        """
        if cls.is_valid_url(target):
            return "url"
        if cls.is_valid_cidr(target) and "/" in target:
            return "cidr"
        if cls.is_valid_ip(target):
            return "ip"
        if cls.is_valid_domain(target):
            return "domain"
        return "unknown"

    @classmethod
    def extract_host(cls, target: str) -> str:
        """Extract hostname/IP from URL or return target as-is."""
        if cls.is_valid_url(target):
            parsed = urlparse(target)
            return parsed.netloc.split(":")[0]
        return target


class ResultsManager:
    """Utility class for managing scan results files."""

    def __init__(self, results_dir: str = "results"):
        self.results_dir = Path(results_dir)
        self.results_dir.mkdir(exist_ok=True)

    def save_json(self, data: Union[Dict, List], prefix: str) -> Path:
        """Save data as JSON file."""
        filepath = self.results_dir / f"{prefix}_{int(time.time())}.json"
        with open(filepath, "w") as f:
            json.dump(data, f, indent=2, default=str)
        return filepath

    def load_json(self, filepath: Union[str, Path]) -> Dict:
        """Load JSON file."""
        with open(filepath, "r") as f:
            return json.load(f)

    def parse_jsonl(self, filepath: Union[str, Path]) -> List[Dict]:
        """Parse JSON Lines file (one JSON object per line)."""
        results = []
        with open(filepath, "r") as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    try:
                        results.append(json.loads(line.rstrip(",")))
                    except json.JSONDecodeError:
                        continue
        return results

    def generate_hash(self, data: str) -> str:
        """Generate SHA-256 hash of data."""
        return hashlib.sha256(data.encode()).hexdigest()


# Utility functions for backward compatibility with function-based plugins

def get_results_dir() -> Path:
    """Get results directory path, creating it if needed."""
    results_dir = Path("results")
    results_dir.mkdir(exist_ok=True)
    return results_dir


def make_error_result(tool: str, target: str, error: str) -> Dict[str, Any]:
    """Create a standardized error result dictionary."""
    return {
        "tool": tool,
        "target": target,
        "status": "error",
        "error": error,
        "timestamp": datetime.utcnow().isoformat(),
    }


def make_success_result(
    tool: str,
    target: str,
    findings: List[Dict] = None,
    **kwargs
) -> Dict[str, Any]:
    """Create a standardized success result dictionary."""
    result = {
        "tool": tool,
        "target": target,
        "status": "completed",
        "timestamp": datetime.utcnow().isoformat(),
    }
    if findings:
        result["findings"] = findings
        result["total_findings"] = len(findings)
    result.update(kwargs)
    return result


# Module-level functions for plugin info (backward compatibility)

def get_status() -> Dict[str, Any]:
    """Return base plugin module status."""
    return {
        "tool": "Base Plugin Framework",
        "version": __version__,
        "status": "available",
        "classes": ["PentestPlugin", "Finding", "ScanResult"],
        "enums": ["ScanType", "Severity", "ScanStatus"],
    }
