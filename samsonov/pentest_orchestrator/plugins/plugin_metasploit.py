#!/usr/bin/env python3
"""
Plugin Metasploit pour l'orchestrateur
"""

__description__ = "Plugin pour Metasploit Framework via msfrpc"
__tool__ = "Metasploit"
__version__ = "1.0.0"

import requests
import json
import time
from typing import Dict, List

# Configuration par défaut
MSF_RPC_URL = "http://127.0.0.1:55553/api"
MSF_RPC_USER = "msf"
MSF_RPC_PASS = "changeme"


class MetasploitRPC:
    """Client RPC pour Metasploit"""
    
    def __init__(self):
        self.url = MSF_RPC_URL
        self.token = None
    
    def login(self):
        """Authentification sur msfrpcd"""
        try:
            response = requests.post(
                f"{self.url}/auth/login",
                json={
                    "username": MSF_RPC_USER,
                    "password": MSF_RPC_PASS
                },
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                self.token = data.get('token')
                return True
            else:
                print(f"[Metasploit] Échec d'authentification : {response.status_code}")
                return False
        except Exception as e:
            print(f"[Metasploit] Erreur de connexion : {e}")
            return False
    
    def call(self, method: str, params: List = None) -> Dict:
        """Appel RPC générique"""
        if not self.token:
            if not self.login():
                return {'error': 'Authentication failed'}
        
        if params is None:
            params = []
        
        payload = {
            "jsonrpc": "2.0",
            "method": method,
            "params": [self.token] + params,
            "id": 1
        }
        
        try:
            response = requests.post(
                self.url,
                json=payload,
                timeout=30
            )
            
            if response.status_code == 200:
                return response.json().get('result', {})
            else:
                return {'error': f'HTTP {response.status_code}'}
        except Exception as e:
            return {'error': str(e)}


# Instance globale
msf_rpc = MetasploitRPC()


def port_scan(target: str, ports: str = "1-1000") -> Dict:
    """
    Scan de ports avec Metasploit
    
    Args:
        target: Cible IP
        ports: Plage de ports
    
    Returns:
        Résultats du scan
    """
    print(f"[Metasploit] Port scan : {target}")
    
    try:
        # Crée une console
        console_id = msf_rpc.call("console.create").get('id')
        
        if not console_id:
            return {
                'tool': 'Metasploit Port Scan',
                'target': target,
                'status': 'error',
                'error': 'Failed to create console'
            }
        
        # Lance le scan avec auxiliary/scanner/portscan/tcp
        commands = [
            f"use auxiliary/scanner/portscan/tcp",
            f"set RHOSTS {target}",
            f"set PORTS {ports}",
            f"set THREADS 10",
            f"run"
        ]
        
        for cmd in commands:
            msf_rpc.call("console.write", [console_id, cmd + "\n"])
            time.sleep(0.5)
        
        # Attend les résultats
        print("[Metasploit] Scan en cours...")
        time.sleep(5)
        
        # Lit la sortie
        output = ""
        for _ in range(30):  # Max 30 secondes
            result = msf_rpc.call("console.read", [console_id])
            if result.get('data'):
                output += result['data']
                if "Scanned" in output and "Auxiliary module execution completed" in output:
                    break
            time.sleep(1)
        
        # Parse les résultats
        open_ports = []
        for line in output.split('\n'):
            if 'is open' in line.lower():
                parts = line.split()
                for part in parts:
                    if part.isdigit():
                        open_ports.append(int(part))
                        break
        
        # Nettoie la console
        msf_rpc.call("console.destroy", [console_id])
        
        return {
            'tool': 'Metasploit Port Scan',
            'target': target,
            'ports_scanned': ports,
            'open_ports': open_ports,
            'total_open': len(open_ports),
            'raw_output': output,
            'status': 'completed'
        }
        
    except Exception as e:
        return {
            'tool': 'Metasploit Port Scan',
            'target': target,
            'status': 'error',
            'error': str(e)
        }


def vulnerability_scan(target: str, scan_type: str = "smb") -> Dict:
    """
    Scan de vulnérabilités avec des modules auxiliaires
    
    Args:
        target: Cible IP
        scan_type: Type de scan (smb, ssh, http, ftp)
    
    Returns:
        Résultats du scan
    """
    print(f"[Metasploit] Vulnerability scan ({scan_type}) : {target}")
    
    # Modules selon le type
    scan_modules = {
        'smb': [
            'auxiliary/scanner/smb/smb_version',
            'auxiliary/scanner/smb/smb_enumshares',
            'auxiliary/scanner/smb/smb_enumusers'
        ],
        'ssh': [
            'auxiliary/scanner/ssh/ssh_version',
            'auxiliary/scanner/ssh/ssh_enumusers'
        ],
        'http': [
            'auxiliary/scanner/http/http_version',
            'auxiliary/scanner/http/http_header',
            'auxiliary/scanner/http/dir_scanner'
        ],
        'ftp': [
            'auxiliary/scanner/ftp/ftp_version',
            'auxiliary/scanner/ftp/anonymous'
        ]
    }
    
    modules = scan_modules.get(scan_type, scan_modules['smb'])
    
    try:
        console_id = msf_rpc.call("console.create").get('id')
        
        if not console_id:
            return {
                'tool': 'Metasploit Vuln Scan',
                'target': target,
                'scan_type': scan_type,
                'status': 'error',
                'error': 'Failed to create console'
            }
        
        results = []
        
        for module in modules:
            print(f"[Metasploit] Module : {module}")
            
            commands = [
                f"use {module}",
                f"set RHOSTS {target}",
                f"set THREADS 5",
                f"run"
            ]
            
            for cmd in commands:
                msf_rpc.call("console.write", [console_id, cmd + "\n"])
                time.sleep(0.3)
            
            # Attend les résultats
            time.sleep(3)
            
            output = ""
            for _ in range(20):
                result = msf_rpc.call("console.read", [console_id])
                if result.get('data'):
                    output += result['data']
                    if "Auxiliary module execution completed" in output:
                        break
                time.sleep(1)
            
            results.append({
                'module': module,
                'output': output
            })
        
        msf_rpc.call("console.destroy", [console_id])
        
        return {
            'tool': 'Metasploit Vuln Scan',
            'target': target,
            'scan_type': scan_type,
            'modules_used': modules,
            'results': results,
            'status': 'completed'
        }
        
    except Exception as e:
        return {
            'tool': 'Metasploit Vuln Scan',
            'target': target,
            'scan_type': scan_type,
            'status': 'error',
            'error': str(e)
        }


def exploit_check(target: str, exploit_name: str) -> Dict:
    """
    Vérifie si une cible est vulnérable à un exploit
    
    Args:
        target: Cible IP
        exploit_name: Nom du module exploit
    
    Returns:
        Résultats du check
    """
    print(f"[Metasploit] Exploit check : {exploit_name} sur {target}")
    
    try:
        console_id = msf_rpc.call("console.create").get('id')
        
        commands = [
            f"use {exploit_name}",
            f"set RHOST {target}",
            f"check"
        ]
        
        for cmd in commands:
            msf_rpc.call("console.write", [console_id, cmd + "\n"])
            time.sleep(0.5)
        
        time.sleep(3)
        
        output = ""
        for _ in range(15):
            result = msf_rpc.call("console.read", [console_id])
            if result.get('data'):
                output += result['data']
            time.sleep(1)
        
        msf_rpc.call("console.destroy", [console_id])
        
        # Détermine si vulnérable
        vulnerable = False
        if "appears to be vulnerable" in output.lower():
            vulnerable = True
        elif "is vulnerable" in output.lower():
            vulnerable = True
        
        return {
            'tool': 'Metasploit Exploit Check',
            'target': target,
            'exploit': exploit_name,
            'vulnerable': vulnerable,
            'output': output,
            'status': 'completed'
        }
        
    except Exception as e:
        return {
            'tool': 'Metasploit Exploit Check',
            'target': target,
            'exploit': exploit_name,
            'status': 'error',
            'error': str(e)
        }


def search_exploits(keyword: str, platform: str = "") -> Dict:
    """
    Recherche des modules d'exploit
    
    Args:
        keyword: Mot-clé de recherche
        platform: Plateforme (windows, linux, etc.)
    
    Returns:
        Liste des exploits trouvés
    """
    print(f"[Metasploit] Recherche : {keyword}")
    
    try:
        search_term = keyword
        if platform:
            search_term += f" platform:{platform}"
        
        result = msf_rpc.call("module.search", [search_term])
        
        if 'modules' in result:
            exploits = [m for m in result['modules'] if m.get('type') == 'exploit']
            
            return {
                'tool': 'Metasploit Search',
                'keyword': keyword,
                'platform': platform,
                'total_found': len(exploits),
                'exploits': exploits[:50],  # Limite les résultats
                'status': 'completed'
            }
        else:
            return {
                'tool': 'Metasploit Search',
                'keyword': keyword,
                'status': 'completed',
                'exploits': []
            }
        
    except Exception as e:
        return {
            'tool': 'Metasploit Search',
            'keyword': keyword,
            'status': 'error',
            'error': str(e)
        }


def get_status() -> Dict:
    """Vérifie le statut de Metasploit RPC"""
    try:
        if msf_rpc.login():
            # Récupère la version
            core_version = msf_rpc.call("core.version")
            
            return {
                'tool': 'Metasploit',
                'status': 'online',
                'version': core_version.get('version', 'unknown'),
                'api': core_version.get('api', 'unknown'),
                'url': MSF_RPC_URL
            }
        else:
            return {
                'tool': 'Metasploit',
                'status': 'authentication_failed',
                'url': MSF_RPC_URL
            }
    except Exception as e:
        return {
            'tool': 'Metasploit',
            'status': 'offline',
            'error': str(e)
        }

