#!/usr/bin/env python3
"""
Plugin Faraday pour l'orchestrateur
Import des résultats de scan vers Faraday
"""

__description__ = "Plugin pour Faraday vulnerability management"
__tool__ = "Faraday"
__version__ = "1.0.0"

import os
import json
import logging
from typing import Dict, List, Any, Optional
from pathlib import Path

try:
    import requests
except ImportError:
    requests = None

try:
    from bojemoi_mitre_attack.mappings.vulnerability import map_vulnerability
except ImportError:
    map_vulnerability = None

logger = logging.getLogger(__name__)

# Configuration par défaut (peut être surchargée par config.json ou env vars)
FARADAY_URL = os.environ.get('FARADAY_URL', 'http://127.0.0.1:5985')
FARADAY_USERNAME = os.environ.get('FARADAY_USERNAME', 'faraday')
FARADAY_PASSWORD = os.environ.get('FARADAY_PASSWORD', 'changeme')
CONFIG_FILE = Path(__file__).parent.parent / "config" / "config.json"


class FaradayClient:
    """Client pour l'API Faraday"""

    def __init__(self, url: str = None, username: str = None, password: str = None):
        self.url = (url or FARADAY_URL).rstrip('/')
        self.username = username or FARADAY_USERNAME
        self.password = password or FARADAY_PASSWORD
        self.session = requests.Session() if requests else None
        self.token = None
        self._load_config()

    def _load_config(self):
        """Charge la configuration depuis config.json"""
        if CONFIG_FILE.exists():
            try:
                with open(CONFIG_FILE) as f:
                    config = json.load(f)
                    faraday_config = config.get('faraday', {})
                    if faraday_config.get('url'):
                        self.url = faraday_config['url'].rstrip('/')
                    if faraday_config.get('username'):
                        self.username = faraday_config['username']
                    if faraday_config.get('password'):
                        self.password = faraday_config['password']
            except Exception as e:
                logger.warning(f"Could not load config: {e}")

    def login(self) -> bool:
        """Authentification à Faraday"""
        if not self.session:
            logger.error("requests library not available")
            return False

        try:
            # Try token-based auth first (Faraday 4.x)
            response = self.session.post(
                f"{self.url}/_api/login",
                json={"email": self.username, "password": self.password},
                timeout=10,
                verify=False
            )

            if response.status_code == 200:
                self.token = response.cookies.get('session') or response.json().get('token')
                logger.info("Faraday login successful")
                return True

            # Fallback to basic auth
            self.session.auth = (self.username, self.password)
            response = self.session.get(f"{self.url}/_api/v3/ws", timeout=10, verify=False)
            if response.status_code == 200:
                logger.info("Faraday login successful (basic auth)")
                return True

            logger.error(f"Faraday login failed: {response.status_code}")
            return False

        except requests.exceptions.ConnectionError:
            logger.error(f"Cannot connect to Faraday at {self.url}")
            return False
        except Exception as e:
            logger.error(f"Faraday login error: {e}")
            return False

    def get_workspaces(self) -> List[str]:
        """Liste les workspaces disponibles"""
        try:
            response = self.session.get(f"{self.url}/_api/v3/ws", timeout=10, verify=False)
            if response.status_code == 200:
                data = response.json()
                rows = data.get('rows', data) if isinstance(data, dict) else data
                return [ws.get('name') for ws in rows if isinstance(ws, dict)]
            return []
        except Exception as e:
            logger.error(f"Error fetching workspaces: {e}")
            return []

    def create_workspace(self, name: str) -> bool:
        """Crée un workspace s'il n'existe pas"""
        try:
            response = self.session.post(
                f"{self.url}/_api/v3/ws",
                json={"name": name},
                timeout=10
            )
            return response.status_code in (200, 201, 409)  # 409 = already exists
        except Exception as e:
            logger.error(f"Error creating workspace: {e}")
            return False

    def create_host(self, workspace: str, ip: str, hostname: str = None) -> Optional[int]:
        """Crée un host dans le workspace"""
        try:
            response = self.session.post(
                f"{self.url}/_api/v3/ws/{workspace}/hosts",
                json={
                    "ip": ip,
                    "hostnames": [hostname] if hostname else [],
                    "description": "Created by pentest orchestrator"
                },
                timeout=10
            )
            if response.status_code in (200, 201):
                return response.json().get('id')
            # Host might already exist, try to find it
            return self._find_host(workspace, ip)
        except Exception as e:
            logger.error(f"Error creating host: {e}")
            return None

    def _find_host(self, workspace: str, ip: str) -> Optional[int]:
        """Trouve un host existant par IP"""
        try:
            response = self.session.get(
                f"{self.url}/_api/v3/ws/{workspace}/hosts",
                params={"search": ip},
                timeout=10
            )
            if response.status_code == 200:
                hosts = response.json().get('rows', [])
                for host in hosts:
                    if host.get('value', {}).get('ip') == ip:
                        return host.get('id')
            return None
        except Exception:
            return None

    def create_vulnerability(self, workspace: str, vuln_data: Dict) -> bool:
        """Crée une vulnérabilité dans Faraday"""
        try:
            response = self.session.post(
                f"{self.url}/_api/v3/ws/{workspace}/vulns",
                json=vuln_data,
                timeout=10
            )
            return response.status_code in (200, 201)
        except Exception as e:
            logger.error(f"Error creating vulnerability: {e}")
            return False


# Singleton client
_client = None

def _get_client() -> FaradayClient:
    """Retourne le client Faraday (singleton)"""
    global _client
    if _client is None:
        _client = FaradayClient()
    return _client


def _map_severity(severity: str) -> str:
    """Mappe les niveaux de sévérité vers Faraday"""
    mapping = {
        'critical': 'critical',
        'high': 'high',
        'medium': 'med',
        'low': 'low',
        'info': 'info',
        'informational': 'info'
    }
    return mapping.get(severity.lower(), 'info')


def _extract_target_ip(target: str) -> str:
    """Extrait l'IP ou hostname d'une URL/target"""
    import re
    from urllib.parse import urlparse

    # If it's a URL
    if target.startswith(('http://', 'https://')):
        parsed = urlparse(target)
        return parsed.hostname or target

    # If it's an IP range, take the first part
    if '/' in target:
        return target.split('/')[0]

    # If it's a range like 192.168.1.1-255
    if '-' in target and not target.startswith('http'):
        return target.split('-')[0]

    return target


def import_results(workspace: str, results: Dict) -> Dict:
    """
    Importe les résultats de scan dans Faraday

    Args:
        workspace: Nom du workspace Faraday
        results: Résultats de l'orchestrateur

    Returns:
        Statut de l'import
    """
    if not requests:
        return {
            'status': 'error',
            'error': 'requests library not installed. Run: pip install requests'
        }

    client = _get_client()

    # Login
    if not client.login():
        return {
            'status': 'error',
            'error': f'Failed to connect to Faraday at {client.url}'
        }

    # Create workspace if needed
    if workspace not in client.get_workspaces():
        client.create_workspace(workspace)

    target = results.get('target', 'unknown')
    target_ip = _extract_target_ip(target)

    # Create host
    host_id = client.create_host(workspace, target_ip, target if target != target_ip else None)

    imported = 0
    errors = 0

    # Process each scan result
    for scan in results.get('scans', []):
        if scan.get('status') != 'success':
            continue

        scan_result = scan.get('result', {})
        tool_name = scan_result.get('tool', scan.get('function', 'Unknown'))

        # Process findings based on tool type
        findings = scan_result.get('findings', [])

        for finding in findings:
            vuln_data = _convert_finding_to_vuln(finding, tool_name, target_ip, host_id)
            if vuln_data and client.create_vulnerability(workspace, vuln_data):
                imported += 1
            else:
                errors += 1

    logger.info(f"Faraday import: {imported} vulns imported, {errors} errors")

    return {
        'status': 'completed',
        'workspace': workspace,
        'target': target,
        'imported': imported,
        'errors': errors
    }


def _enrich_with_attack_tags(vuln_data: Dict, finding: Dict) -> Dict:
    """Enrich a vulnerability with MITRE ATT&CK tags if the library is available."""
    if not map_vulnerability or not vuln_data:
        return vuln_data

    vuln_name = vuln_data.get('name', '')
    severity = vuln_data.get('severity', 'info')
    cve = vuln_data.get('external_id', '')

    try:
        mapping = map_vulnerability(vuln_name, severity, cve)
        if mapping:
            # Add mitre tag
            tags = vuln_data.get('tags', [])
            if not isinstance(tags, list):
                tags = []
            tags.append(f"mitre:{mapping.technique_id}")
            tags.append(f"tactic:{mapping.tactic}")
            vuln_data['tags'] = tags

            # Add ATT&CK reference URL
            refs = vuln_data.get('refs', [])
            if not isinstance(refs, list):
                refs = []
            attack_url = f"https://attack.mitre.org/techniques/{mapping.technique_id.replace('.', '/')}/"
            refs.append(attack_url)
            vuln_data['refs'] = refs

            # Append ATT&CK info to description
            desc = vuln_data.get('desc', '')
            attack_section = (
                f"\n\n--- MITRE ATT&CK ---\n"
                f"Technique: {mapping.technique_id} - {mapping.technique_name}\n"
                f"Tactic: {mapping.tactic}\n"
                f"Confidence: {mapping.confidence}\n"
            )
            vuln_data['desc'] = desc + attack_section
    except Exception as e:
        logger.debug(f"ATT&CK enrichment failed for {vuln_name}: {e}")

    return vuln_data


def _convert_finding_to_vuln(finding: Dict, tool: str, target_ip: str, host_id: int) -> Optional[Dict]:
    """Convertit un finding en format Faraday vulnerability"""

    # Nuclei format
    if 'template-id' in finding or 'info' in finding:
        vuln_data = _convert_nuclei_finding(finding, target_ip, host_id)
    # ZAP format
    elif 'alert' in finding or 'alertRef' in finding:
        vuln_data = _convert_zap_finding(finding, target_ip, host_id)
    # Masscan format
    elif 'ports' in finding:
        vuln_data = _convert_masscan_finding(finding, target_ip, host_id)
    # VulnX format
    elif 'vulnerability' in finding or 'cms' in finding:
        vuln_data = _convert_vulnx_finding(finding, target_ip, host_id)
    # Generic format
    else:
        vuln_data = _convert_generic_finding(finding, tool, target_ip, host_id)

    return _enrich_with_attack_tags(vuln_data, finding)


def _convert_nuclei_finding(finding: Dict, target_ip: str, host_id: int) -> Dict:
    """Convertit un finding Nuclei"""
    info = finding.get('info', {})

    return {
        'name': info.get('name', finding.get('template-id', 'Nuclei Finding')),
        'desc': info.get('description', ''),
        'severity': _map_severity(info.get('severity', 'info')),
        'type': 'Vulnerability',
        'parent': host_id,
        'parent_type': 'Host',
        'method': '',
        'path': finding.get('matched-at', ''),
        'request': finding.get('request', ''),
        'response': finding.get('response', '')[:5000] if finding.get('response') else '',
        'refs': info.get('reference', []) if isinstance(info.get('reference'), list) else [],
        'tags': info.get('tags', []) if isinstance(info.get('tags'), list) else [],
        'data': json.dumps({
            'template_id': finding.get('template-id'),
            'matcher_name': finding.get('matcher-name'),
            'extractor': finding.get('extracted-results', [])
        }),
        'external_id': finding.get('template-id', '')
    }


def _convert_zap_finding(finding: Dict, target_ip: str, host_id: int) -> Dict:
    """Convertit un finding ZAP"""
    risk_map = {'0': 'info', '1': 'low', '2': 'med', '3': 'high'}

    return {
        'name': finding.get('alert', finding.get('name', 'ZAP Finding')),
        'desc': finding.get('description', finding.get('desc', '')),
        'severity': risk_map.get(str(finding.get('risk', 0)), 'info'),
        'type': 'Vulnerability',
        'parent': host_id,
        'parent_type': 'Host',
        'method': finding.get('method', ''),
        'path': finding.get('url', finding.get('uri', '')),
        'request': finding.get('request', ''),
        'response': finding.get('response', '')[:5000] if finding.get('response') else '',
        'resolution': finding.get('solution', ''),
        'refs': [finding.get('reference')] if finding.get('reference') else [],
        'data': finding.get('evidence', ''),
        'external_id': finding.get('alertRef', finding.get('pluginId', ''))
    }


def _convert_masscan_finding(finding: Dict, target_ip: str, host_id: int) -> Dict:
    """Convertit un finding Masscan (port ouvert)"""
    ports = finding.get('ports', [])
    if not ports:
        return None

    port_info = ports[0]
    port = port_info.get('port', 0)
    proto = port_info.get('proto', 'tcp')
    service = port_info.get('service', {}).get('name', 'unknown')

    return {
        'name': f"Open Port: {port}/{proto} ({service})",
        'desc': f"Port {port}/{proto} is open. Service: {service}",
        'severity': 'info',
        'type': 'Vulnerability',
        'parent': host_id,
        'parent_type': 'Host',
        'data': json.dumps(port_info),
        'external_id': f"masscan-{port}-{proto}"
    }


def _convert_vulnx_finding(finding: Dict, target_ip: str, host_id: int) -> Dict:
    """Convertit un finding VulnX"""
    return {
        'name': finding.get('vulnerability', finding.get('name', 'VulnX Finding')),
        'desc': finding.get('description', ''),
        'severity': _map_severity(finding.get('severity', 'medium')),
        'type': 'Vulnerability',
        'parent': host_id,
        'parent_type': 'Host',
        'path': finding.get('url', ''),
        'data': json.dumps({
            'cms': finding.get('cms'),
            'version': finding.get('version'),
            'exploit': finding.get('exploit')
        }),
        'external_id': finding.get('id', '')
    }


def _convert_generic_finding(finding: Dict, tool: str, target_ip: str, host_id: int) -> Dict:
    """Convertit un finding générique"""
    return {
        'name': finding.get('name', finding.get('title', f'{tool} Finding')),
        'desc': finding.get('description', finding.get('desc', str(finding))),
        'severity': _map_severity(finding.get('severity', 'info')),
        'type': 'Vulnerability',
        'parent': host_id,
        'parent_type': 'Host',
        'data': json.dumps(finding),
        'external_id': finding.get('id', '')
    }


def get_status() -> Dict:
    """Vérifie le statut de la connexion Faraday"""
    if not requests:
        return {
            'tool': 'Faraday',
            'status': 'error',
            'error': 'requests library not installed'
        }

    client = _get_client()

    if client.login():
        workspaces = client.get_workspaces()
        return {
            'tool': 'Faraday',
            'status': 'connected',
            'url': client.url,
            'workspaces': workspaces
        }
    else:
        return {
            'tool': 'Faraday',
            'status': 'disconnected',
            'url': client.url,
            'error': 'Cannot connect or authenticate'
        }


def list_workspaces() -> Dict:
    """Liste tous les workspaces Faraday"""
    client = _get_client()

    if not client.login():
        return {
            'status': 'error',
            'error': 'Cannot connect to Faraday'
        }

    return {
        'status': 'success',
        'workspaces': client.get_workspaces()
    }


def create_workspace(name: str) -> Dict:
    """Crée un nouveau workspace"""
    client = _get_client()

    if not client.login():
        return {
            'status': 'error',
            'error': 'Cannot connect to Faraday'
        }

    if client.create_workspace(name):
        return {
            'status': 'success',
            'workspace': name
        }
    else:
        return {
            'status': 'error',
            'error': f'Failed to create workspace: {name}'
        }
