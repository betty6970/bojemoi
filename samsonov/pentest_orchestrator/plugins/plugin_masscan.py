#!/usr/bin/env python3
"""
Plugin Masscan pour l'orchestrateur
Supporte les scans par pays via ip2location PostgreSQL
"""

__description__ = "Plugin pour Masscan - Fast port scanner avec support ip2location"
__tool__ = "Masscan"
__version__ = "2.0.0"

import subprocess
import json
import os
import logging
from typing import Dict, List
import xml.etree.ElementTree as ET
from datetime import datetime
import ipaddress

logger = logging.getLogger(__name__)

# Configuration PostgreSQL ip2location
IP2LOC_CONFIG = {
    'host': os.environ.get('IP2LOC_HOST', 'postgres'),
    'port': int(os.environ.get('IP2LOC_PORT', 5432)),
    'database': os.environ.get('IP2LOC_DB', 'ip2location'),
    'user': os.environ.get('IP2LOC_USER', 'postgres'),
    'password': os.environ.get('IP2LOC_PASSWORD', 'postgres'),
    'table': os.environ.get('IP2LOC_TABLE', 'ip2location_db1'),
}


def _get_db_connection():
    """Connexion PostgreSQL vers ip2location"""
    try:
        import psycopg2
    except ImportError:
        subprocess.check_call([
            'pip', 'install', 'psycopg2-binary', '--break-system-packages'
        ])
        import psycopg2

    return psycopg2.connect(
        host=IP2LOC_CONFIG['host'],
        port=IP2LOC_CONFIG['port'],
        database=IP2LOC_CONFIG['database'],
        user=IP2LOC_CONFIG['user'],
        password=IP2LOC_CONFIG['password']
    )


def _parse_json_results(output_file: str) -> List[Dict]:
    """Parse les résultats JSON de masscan"""
    open_ports = []
    if os.path.exists(output_file):
        with open(output_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    try:
                        data = json.loads(line.rstrip(','))
                        if 'ports' in data:
                            for port_info in data['ports']:
                                open_ports.append({
                                    'ip': data.get('ip', ''),
                                    'port': port_info.get('port', 0),
                                    'protocol': port_info.get('proto', 'tcp'),
                                    'status': port_info.get('status', 'open')
                                })
                    except json.JSONDecodeError:
                        continue
    return open_ports


def _cidr_to_ip_count(cidr: str) -> int:
    """Calcule le nombre d'IPs dans un CIDR"""
    try:
        network = ipaddress.ip_network(cidr, strict=False)
        return network.num_addresses
    except:
        return 0


def get_country_cidrs(country_code: str = "RU", limit: int = 0, only_unscanned: bool = False) -> Dict:
    """
    Récupère les CIDR d'un pays depuis ip2location PostgreSQL

    Args:
        country_code: Code pays ISO 2 lettres (RU, CN, US, etc.)
        limit: Limite le nombre de ranges (0 = illimité)
        only_unscanned: Si True, ne retourne que les CIDR avec nmap='0'

    Returns:
        Dict avec liste des CIDR et stats
    """
    logger.info(f"[Masscan] Récupération CIDR pour {country_code}")

    try:
        conn = _get_db_connection()
        cursor = conn.cursor()

        # Utilise cidr_z directement (format CIDR natif PostgreSQL)
        query = f"""
            SELECT cidr_z::text, nmap
            FROM {IP2LOC_CONFIG['table']}
            WHERE country_code = %s
        """
        if only_unscanned:
            query += " AND nmap = '0'"
        query += " ORDER BY cidr_z"

        if limit > 0:
            query += f" LIMIT {limit}"

        cursor.execute(query, (country_code.upper(),))
        rows = cursor.fetchall()

        cidrs = []
        total_ips = 0

        for cidr_z, nmap in rows:
            cidrs.append(cidr_z)
            total_ips += _cidr_to_ip_count(cidr_z)

        cursor.close()
        conn.close()

        logger.info(f"[Masscan] {len(cidrs)} CIDR pour {country_code} ({total_ips:,} IPs)")

        return {
            'tool': 'Masscan IP2Location',
            'country_code': country_code,
            'total_cidrs': len(cidrs),
            'total_ips': total_ips,
            'cidrs': cidrs,
            'status': 'success'
        }
    except Exception as e:
        logger.error(f"[Masscan] Erreur DB: {e}")
        return {
            'tool': 'Masscan IP2Location',
            'country_code': country_code,
            'status': 'error',
            'error': str(e)
        }


def update_scan_status(cidrs: List[str], status: str = "1") -> Dict:
    """
    Met à jour le statut nmap des CIDR scannés

    Args:
        cidrs: Liste des CIDR scannés
        status: Nouveau statut ('0'=non scannés, '1'=en cours, '2'=terminé)
    """
    try:
        conn = _get_db_connection()
        cursor = conn.cursor()

        query = f"""
            UPDATE {IP2LOC_CONFIG['table']}
            SET nmap = %s, date_nmap = NOW()
            WHERE cidr_z::text = ANY(%s)
        """
        cursor.execute(query, (status, cidrs))
        updated = cursor.rowcount
        conn.commit()
        cursor.close()
        conn.close()

        logger.info(f"[Masscan] {updated} CIDR mis à jour (nmap={status})")
        return {'updated': updated, 'status': 'success'}
    except Exception as e:
        logger.error(f"[Masscan] Erreur update: {e}")
        return {'status': 'error', 'error': str(e)}


def reset_country_scan_status(country_code: str = "RU") -> Dict:
    """
    Réinitialise le statut nmap d'un pays à '0' (non scanné)

    Args:
        country_code: Code pays ISO (RU, CN, US, etc.)

    Returns:
        Nombre de CIDR réinitialisés
    """
    logger.info(f"[Masscan] Reset nmap='0' pour {country_code}")

    try:
        conn = _get_db_connection()
        cursor = conn.cursor()

        query = f"""
            UPDATE {IP2LOC_CONFIG['table']}
            SET nmap = '0', date_nmap = NULL
            WHERE country_code = %s
        """
        cursor.execute(query, (country_code.upper(),))
        updated = cursor.rowcount
        conn.commit()
        cursor.close()
        conn.close()

        logger.info(f"[Masscan] {updated} CIDR réinitialisés pour {country_code}")
        return {
            'tool': 'Masscan IP2Location',
            'country_code': country_code,
            'reset_count': updated,
            'status': 'success'
        }
    except Exception as e:
        logger.error(f"[Masscan] Erreur reset: {e}")
        return {
            'tool': 'Masscan IP2Location',
            'country_code': country_code,
            'status': 'error',
            'error': str(e)
        }


def country_scan(
    country_code: str = "RU",
    ports: str = "22,80,443,3389,8080",
    rate: int = 100000,
    max_ranges: int = 0,
    only_unscanned: bool = False,
    update_db: bool = True
) -> Dict:
    """
    Scan tous les CIDR d'un pays depuis ip2location

    Args:
        country_code: Code pays ISO (RU, CN, US, etc.)
        ports: Ports à scanner
        rate: Paquets/sec
        max_ranges: Limite de ranges (0 = tous)
        only_unscanned: Si True, ne scanne que les CIDR avec nmap='0'
        update_db: Si True, met à jour le statut nmap après scan

    Returns:
        Résultats agrégés du scan
    """
    logger.info(f"[Masscan] Démarrage scan {country_code}")

    cidr_result = get_country_cidrs(country_code, max_ranges, only_unscanned)
    if cidr_result['status'] != 'success':
        return cidr_result

    cidrs = cidr_result['cidrs']
    if not cidrs:
        return {
            'tool': 'Masscan Country',
            'country_code': country_code,
            'status': 'error',
            'error': f'Aucun CIDR pour {country_code}' + (' (non scannés)' if only_unscanned else '')
        }

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_file = f"results/masscan_{country_code.lower()}_{timestamp}.json"
    targets_file = f"results/masscan_{country_code.lower()}_{timestamp}_targets.txt"

    os.makedirs("results", exist_ok=True)
    with open(targets_file, 'w') as f:
        for cidr in cidrs:
            f.write(f"{cidr}\n")

    logger.info(f"[Masscan] {len(cidrs)} CIDR → {targets_file}")
    logger.info(f"[Masscan] Scan {cidr_result['total_ips']:,} IPs")

    # Marque les CIDR comme en cours de scan
    if update_db:
        update_scan_status(cidrs, status="1")

    try:
        cmd = [
            "masscan",
            "-iL", targets_file,
            "-p", ports,
            "--rate", str(rate),
            "-oJ", output_file,
            "--open"
        ]

        logger.info(f"[Masscan] {' '.join(cmd)}")

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=86400  # 24h max
        )

        if result.returncode == 0:
            # Marque les CIDR comme scannés
            if update_db:
                update_scan_status(cidrs, status="2")

            open_ports = _parse_json_results(output_file)

            port_summary = {}
            for port in open_ports:
                port_num = port['port']
                port_summary[port_num] = port_summary.get(port_num, 0) + 1

            return {
                'tool': 'Masscan Country',
                'country_code': country_code,
                'total_cidrs': len(cidrs),
                'total_target_ips': cidr_result['total_ips'],
                'ports_scanned': ports,
                'rate': rate,
                'total_open_ports': len(open_ports),
                'port_summary': port_summary,
                'open_ports': open_ports[:1000],
                'output_file': output_file,
                'targets_file': targets_file,
                'status': 'completed'
            }
        else:
            return {
                'tool': 'Masscan Country',
                'country_code': country_code,
                'status': 'error',
                'error': result.stderr or result.stdout
            }
    except subprocess.TimeoutExpired:
        return {
            'tool': 'Masscan Country',
            'country_code': country_code,
            'status': 'timeout',
            'error': 'Scan timeout (24h)'
        }
    except Exception as e:
        return {
            'tool': 'Masscan Country',
            'country_code': country_code,
            'status': 'error',
            'error': str(e)
        }


def russia_scan(
    ports: str = "22,80,443,3389,8080",
    rate: int = 100000,
    max_ranges: int = 0
) -> Dict:
    """
    Scan toutes les IPs russes depuis ip2location
    Réinitialise automatiquement nmap='0' avant le scan

    Args:
        ports: Ports à scanner
        rate: Paquets/sec
        max_ranges: Limite de ranges (0 = tous)
    """
    # Reset nmap='0' pour tous les CIDR russes avant le scan
    reset_result = reset_country_scan_status("RU")
    if reset_result['status'] != 'success':
        return reset_result

    logger.info(f"[Masscan] {reset_result['reset_count']} CIDR RU réinitialisés, lancement scan...")

    return country_scan("RU", ports, rate, max_ranges, only_unscanned=False, update_db=True)


def quick_scan(target: str, ports: str = "0-1000", rate: int = 10000) -> Dict:
    """
    Scan rapide des ports communs
    
    Args:
        target: Cible (IP ou réseau CIDR)
        ports: Ports à scanner (ex: "80,443" ou "0-1000")
        rate: Vitesse de scan (paquets/sec)
    
    Returns:
        Résultats du scan
    """
    print(f"[Masscan] Quick scan : {target}")
    
    output_file = f"results/masscan_quick_{target.replace('/', '_')}.json"
    
    try:
        cmd = [
            "masscan",
            target,
            "-p", ports,
            "--rate", str(rate),
            "-oJ", output_file,
            "--open"
        ]
        
        print(f"[Masscan] Commande : {' '.join(cmd)}")
        
        # Exécute masscan
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=300  # 5 minutes max
        )
        
        if result.returncode == 0:
            # Parse les résultats JSON
            open_ports = []
            if os.path.exists(output_file):
                with open(output_file, 'r') as f:
                    # Masscan génère du JSON line-by-line
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            try:
                                data = json.loads(line.rstrip(','))
                                if 'ports' in data:
                                    for port_info in data['ports']:
                                        open_ports.append({
                                            'ip': data.get('ip', ''),
                                            'port': port_info.get('port', 0),
                                            'protocol': port_info.get('proto', 'tcp'),
                                            'status': port_info.get('status', 'open')
                                        })
                            except json.JSONDecodeError:
                                continue
            
            # Analyse des résultats
            port_summary = {}
            for port in open_ports:
                port_num = port['port']
                port_summary[port_num] = port_summary.get(port_num, 0) + 1
            
            return {
                'tool': 'Masscan Quick',
                'target': target,
                'ports_scanned': ports,
                'rate': rate,
                'total_open_ports': len(open_ports),
                'unique_ports': len(port_summary),
                'port_summary': port_summary,
                'open_ports': open_ports[:100],  # Limite les résultats
                'output_file': output_file,
                'status': 'completed'
            }
        else:
            error_msg = result.stderr or result.stdout
            return {
                'tool': 'Masscan Quick',
                'target': target,
                'status': 'error',
                'error': error_msg
            }
            
    except subprocess.TimeoutExpired:
        return {
            'tool': 'Masscan Quick',
            'target': target,
            'status': 'error',
            'error': 'Scan timeout (5 minutes)'
        }
    except FileNotFoundError:
        print("[Masscan] ERREUR : Masscan n'est pas installé")
        return {
            'tool': 'Masscan Quick',
            'target': target,
            'status': 'error',
            'error': 'Masscan not installed'
        }
    except Exception as e:
        return {
            'tool': 'Masscan Quick',
            'target': target,
            'status': 'error',
            'error': str(e)
        }


def full_scan(target: str, rate: int = 100000, exclude_ports: str = "") -> Dict:
    """
    Scan complet de tous les ports
    
    Args:
        target: Cible (IP ou réseau CIDR)
        rate: Vitesse de scan (paquets/sec)
        exclude_ports: Ports à exclure
    
    Returns:
        Résultats du scan complet
    """
    print(f"[Masscan] Full scan : {target}")
    
    output_file = f"results/masscan_full_{target.replace('/', '_')}.json"
    
    try:
        cmd = [
            "masscan",
            target,
            "-p", "0-65535",
            "--rate", str(rate),
            "-oJ", output_file,
            "--open"
        ]
        
        if exclude_ports:
            cmd.extend(["--exclude-ports", exclude_ports])
        
        print(f"[Masscan] Commande : {' '.join(cmd)}")
        print("[Masscan] ATTENTION : Scan complet en cours, cela peut prendre du temps...")
        
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=3600  # 1 heure max
        )
        
        if result.returncode == 0:
            open_ports = []
            if os.path.exists(output_file):
                with open(output_file, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            try:
                                data = json.loads(line.rstrip(','))
                                if 'ports' in data:
                                    for port_info in data['ports']:
                                        open_ports.append({
                                            'ip': data.get('ip', ''),
                                            'port': port_info.get('port', 0),
                                            'protocol': port_info.get('proto', 'tcp'),
                                            'status': port_info.get('status', 'open')
                                        })
                            except json.JSONDecodeError:
                                continue
            
            # Groupement par service commun
            service_ports = {
                'web': [80, 443, 8080, 8443, 8000, 8888],
                'database': [3306, 5432, 1433, 27017, 6379, 9200],
                'remote': [22, 23, 3389, 5900, 5901],
                'mail': [25, 110, 143, 465, 587, 993, 995],
                'file': [21, 445, 139, 2049, 111]
            }
            
            services_found = {}
            for port in open_ports:
                port_num = port['port']
                for service, ports_list in service_ports.items():
                    if port_num in ports_list:
                        services_found[service] = services_found.get(service, 0) + 1
            
            return {
                'tool': 'Masscan Full',
                'target': target,
                'rate': rate,
                'total_open_ports': len(open_ports),
                'services_found': services_found,
                'open_ports': open_ports,
                'output_file': output_file,
                'status': 'completed'
            }
        else:
            error_msg = result.stderr or result.stdout
            return {
                'tool': 'Masscan Full',
                'target': target,
                'status': 'error',
                'error': error_msg
            }
            
    except subprocess.TimeoutExpired:
        return {
            'tool': 'Masscan Full',
            'target': target,
            'status': 'error',
            'error': 'Scan timeout (1 hour)'
        }
    except FileNotFoundError:
        print("[Masscan] ERREUR : Masscan n'est pas installé")
        return {
            'tool': 'Masscan Full',
            'target': target,
            'status': 'error',
            'error': 'Masscan not installed'
        }
    except Exception as e:
        return {
            'tool': 'Masscan Full',
            'target': target,
            'status': 'error',
            'error': str(e)
        }


def service_scan(target: str, service: str = "web") -> Dict:
    """
    Scan ciblé sur des ports de service spécifiques
    
    Args:
        target: Cible
        service: Type de service (web, database, remote, mail, file)
    
    Returns:
        Résultats du scan
    """
    print(f"[Masscan] Service scan : {service} sur {target}")
    
    service_ports = {
        'web': '80,443,8080,8443,8000,8888,3000,5000',
        'database': '3306,5432,1433,27017,6379,9200,5984,7474',
        'remote': '22,23,3389,5900,5901,5902',
        'mail': '25,110,143,465,587,993,995',
        'file': '21,445,139,2049,111,873',
        'all_common': '21,22,23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5432,5900,8080,8443'
    }
    
    ports = service_ports.get(service, service_ports['all_common'])
    
    return quick_scan(target, ports=ports, rate=50000)


def parse_xml_output(xml_file: str) -> Dict:
    """
    Parse un fichier XML de sortie Masscan
    
    Args:
        xml_file: Chemin du fichier XML
    
    Returns:
        Résultats parsés
    """
    try:
        tree = ET.parse(xml_file)
        root = tree.getroot()
        
        hosts = []
        for host in root.findall('host'):
            host_info = {
                'ip': host.find('address').get('addr'),
                'ports': []
            }
            
            for port in host.findall('.//port'):
                host_info['ports'].append({
                    'port': int(port.get('portid')),
                    'protocol': port.get('protocol'),
                    'state': port.find('state').get('state')
                })
            
            hosts.append(host_info)
        
        return {
            'tool': 'Masscan XML Parser',
            'hosts': hosts,
            'total_hosts': len(hosts)
        }
        
    except Exception as e:
        return {
            'tool': 'Masscan XML Parser',
            'status': 'error',
            'error': str(e)
        }


def get_version() -> Dict:
    """Récupère la version de Masscan"""
    try:
        result = subprocess.run(
            ["masscan", "--version"],
            capture_output=True,
            text=True,
            timeout=5
        )
        
        if result.returncode == 0:
            version = result.stdout.strip()
            return {
                'tool': 'Masscan',
                'status': 'installed',
                'version': version
            }
        else:
            return {
                'tool': 'Masscan',
                'status': 'error',
                'error': result.stderr
            }
    except FileNotFoundError:
        return {
            'tool': 'Masscan',
            'status': 'not_installed',
            'error': 'Masscan not found in PATH'
        }
    except Exception as e:
        return {
            'tool': 'Masscan',
            'status': 'error',
            'error': str(e)
        }

